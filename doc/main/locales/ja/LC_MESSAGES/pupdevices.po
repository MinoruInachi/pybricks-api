# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018-2023 The Pybricks Authors
# This file is distributed under the same license as the pybricks package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybricks v3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-03-12 12:22+0900\n"
"PO-Revision-Date: 2024-03-12 12:48+0900\n"
"Last-Translator: Minoru INACHI\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../pupdevices/colordistancesensor.rst:4
msgid "Color and Distance Sensor"
msgstr "カラー/距離センサー"

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-colordistance.png"
msgstr ""

#: of pybricks.pupdevices.ColorDistanceSensor:1
msgid "LEGO® Powered Up Color and Distance Sensor."
msgstr "LEGO® Powered Up カラー/距離センサー"

#: of pybricks._common.AmbientColorSensor.color
#: pybricks._common.AmbientColorSensor.hsv pybricks._common.ColorLight.on
#: pybricks._common.CommonColorSensor.detectable_colors
#: pybricks._common.Control.limits pybricks._common.Control.pid
#: pybricks._common.Control.stall_tolerances
#: pybricks._common.Control.target_tolerances pybricks._common.DCMotor.dc
#: pybricks._common.DCMotor.settings pybricks._common.LightArray3.on
#: pybricks._common.LightArray4.on pybricks._common.Model.settings
#: pybricks._common.Motor.run pybricks._common.Motor.run_angle
#: pybricks._common.Motor.run_target pybricks._common.Motor.run_time
#: pybricks._common.Motor.run_until_stalled pybricks._common.Motor.track_target
#: pybricks.pupdevices.ColorDistanceSensor pybricks.pupdevices.ColorLightMatrix
#: pybricks.pupdevices.ColorLightMatrix.on pybricks.pupdevices.ColorSensor
#: pybricks.pupdevices.DCMotor pybricks.pupdevices.ForceSensor
#: pybricks.pupdevices.ForceSensor.pressed pybricks.pupdevices.InfraredSensor
#: pybricks.pupdevices.Light pybricks.pupdevices.Light.on
#: pybricks.pupdevices.Motor pybricks.pupdevices.Motor.reset_angle
#: pybricks.pupdevices.PFMotor pybricks.pupdevices.Remote
#: pybricks.pupdevices.Remote.name pybricks.pupdevices.TiltSensor
#: pybricks.pupdevices.UltrasonicSensor
msgid "Parameters"
msgstr "パラメータ"

#: of pybricks.pupdevices.ColorDistanceSensor:3
#: pybricks.pupdevices.ColorSensor:3 pybricks.pupdevices.ForceSensor:3
#: pybricks.pupdevices.InfraredSensor:3 pybricks.pupdevices.TiltSensor:3
#: pybricks.pupdevices.UltrasonicSensor:3
msgid "Port to which the sensor is connected."
msgstr "センサーが接続されているポート。"

#: of pybricks._common.CommonColorSensor.color:1
#: pybricks._common.CommonColorSensor.hsv:1
msgid "Scans the color of a surface."
msgstr "表面色のスキャン"

#: of pybricks._common.AmbientColorSensor.color:3
#: pybricks._common.CommonColorSensor.color:3
msgid ""
"You choose which colors are detected using the ``detectable_colors()`` "
"method. By default, it detects ``Color.RED``, ``Color.YELLOW``, "
"``Color.GREEN``, ``Color.BLUE``, ``Color.WHITE``, or ``Color.NONE``."
msgstr ""
"検出する色は ``detectable_colors()`` メソッドで選択します。"
"デフォルトでは ``Color.RED``, ``Color.YELLOW``, ``Color.GREEN``, "
"``Color.BLUE``, ``Color.WHITE``, ``Color.NONE`` を検出します。"

#: of pybricks._common.AmbientColorSensor.color
#: pybricks._common.AmbientColorSensor.hsv
#: pybricks._common.CommonColorSensor.ambient
#: pybricks._common.CommonColorSensor.color
#: pybricks._common.CommonColorSensor.hsv
#: pybricks._common.CommonColorSensor.reflection
#: pybricks._common.Keypad.pressed pybricks._common.Model.state
#: pybricks._common.Motor.angle pybricks._common.Motor.done
#: pybricks._common.Motor.load pybricks._common.Motor.run_until_stalled
#: pybricks._common.Motor.speed pybricks._common.Motor.stalled
#: pybricks.pupdevices.ColorDistanceSensor.distance
#: pybricks.pupdevices.ForceSensor.distance
#: pybricks.pupdevices.ForceSensor.force
#: pybricks.pupdevices.ForceSensor.pressed
#: pybricks.pupdevices.ForceSensor.touched
#: pybricks.pupdevices.InfraredSensor.count
#: pybricks.pupdevices.InfraredSensor.distance
#: pybricks.pupdevices.InfraredSensor.reflection
#: pybricks.pupdevices.TiltSensor.tilt
#: pybricks.pupdevices.UltrasonicSensor.distance
#: pybricks.pupdevices.UltrasonicSensor.presence
msgid "Returns"
msgstr "戻り値"

#: of pybricks._common.CommonColorSensor.color:8
msgid "Detected color."
msgstr "検出した色。"

#: of pybricks._common.CommonColorSensor.reflection:1
msgid "Measures how much a surface reflects the light emitted by the sensor."
msgstr "センサーが照射した光を表面がどれだけ反射しているかを計測します。"

#: of pybricks._common.CommonColorSensor.reflection:4
#: pybricks.pupdevices.InfraredSensor.reflection:3
msgid ""
"Measured reflection, ranging from 0% (no reflection) to 100% (high "
"reflection)."
msgstr ""
"0% (反射なし)から100% (高反射)までの反射率の計測値。"

#: of pybricks._common.CommonColorSensor.ambient:1
msgid "Measures the ambient light intensity."
msgstr "周囲光を計測します。"

#: of pybricks._common.CommonColorSensor.ambient:3
msgid "Ambient light intensity, ranging from 0% (dark) to 100% (bright)."
msgstr "0%(暗い)から100%(明るい)までの範囲の周囲光の強さ。"

#: of pybricks.pupdevices.ColorDistanceSensor.distance:1
#: pybricks.pupdevices.InfraredSensor.distance:1
msgid ""
"Measures the relative distance between the sensor and an object using "
"infrared light."
msgstr ""
"センサーと対象物との相対距離を赤外線で計測します。"

#: of pybricks.pupdevices.ColorDistanceSensor.distance:4
#: pybricks.pupdevices.InfraredSensor.distance:4
msgid "Distance ranging from 0% (closest) to 100% (farthest)."
msgstr "0% (最も近い)から100% (最も遠い)までの距離。"

#: of pybricks._common.AmbientColorSensor.hsv:3
#: pybricks._common.CommonColorSensor.hsv:3
msgid ""
"This method is similar to ``color()``, but it gives the full range of "
"hue, saturation and brightness values, instead of rounding it to the "
"nearest detectable color."
msgstr ""
"このメソッドは ``color()`` に似ていますが、検出可能な最も近い色に丸めるのではなく、"
"色相、彩度、明度の全範囲の値を取得します。"

#: of pybricks._common.AmbientColorSensor.hsv:12
#: pybricks._common.CommonColorSensor.hsv:7
msgid ""
"Measured color. The color is described by a hue (0--359), a saturation (0"
"--100), and a brightness value (0--100)."
msgstr ""
"計測した色。色は、色相(0--359)、彩度(0--100)、明度(0--100)の値で表現されます。"

#: of pybricks._common.CommonColorSensor.detectable_colors:1
msgid "Configures which colors the ``color()`` method should detect."
msgstr "``color()`` メソッドが検出する色を設定します。"

#: of pybricks._common.CommonColorSensor.detectable_colors:3
msgid ""
"Specify only colors that you wish to detect in your application. This "
"way, the full-color measurements are rounded to the nearest desired "
"color, and other colors are ignored. This improves reliability."
msgstr ""
"アプリケーションで検出したい色のみを指定します。"
"こうすると、フルカラーで計測した結果を最も近い希望する色に丸め、"
"それ以外の色は無視されます。これにより、信頼性が向上します。"

#: of pybricks._common.CommonColorSensor.detectable_colors:7
msgid "If you give no arguments, the currently chosen colors will be returned."
msgstr "引数を与えない場合は、現在選択されている色が返されます。"

#: of pybricks._common.CommonColorSensor.detectable_colors:9
msgid ""
"List of :class:`Color <.parameters.Color>` objects: the colors that you "
"want to detect. You can pick standard colors such as ``Color.MAGENTA``, "
"or provide your own colors like ``Color(h=348, s=96, v=40)`` for even "
"better results. You measure your own colors with the ``hsv()`` method."
msgstr ""
"検出したい色(:class:`Color <.parameters.Color>` オブジェクト)のリスト。 "
"``Color.MAGENTA`` のような標準色を選ぶこともできますし、 "
"``Color(h=348, s=96, v=40)``のように独自色を用意すれば、"
"さらによい結果を得ることができます。独自色は ``hsv()`` メソッドで計測します。"

#: ../../pupdevices/colordistancesensor.rst:25
msgid "Built-in light"
msgstr "内蔵ライト"

#: ../../pupdevices/colordistancesensor.rst:26
msgid ""
"This sensor has a built-in light. You can make it red, green, blue, or "
"turn it off. If you use the sensor to measure something afterwards, the "
"light automatically turns back on at the default color for that sensing "
"method."
msgstr ""
"このセンサーはライトを内蔵しています。赤、緑、青にしたり、消したりできます。"
"この後、センサーを使って何かを計測する場合、ライトは自動的にそのセンシング方法の"
"デフォルトの色で点灯しなおします。"

#: of pybricks._common.ColorLight.on:1
msgid "Turns on the light at the specified color."
msgstr "指定した色でライトを点灯します。"

#: of pybricks._common.ColorLight.on:3
msgid "Color of the light."
msgstr "ライトの色。"

#: of pybricks._common.ColorLight.off:1 pybricks.pupdevices.Light.off:1
msgid "Turns off the light."
msgstr "ライトを消灯します。"

#: ../../pupdevices/colordistancesensor.rst:35
#: ../../pupdevices/colorsensor.rst:36 ../../pupdevices/dcmotor.rst:32
#: ../../pupdevices/forcesensor.rst:21 ../../pupdevices/infraredsensor.rst:19
#: ../../pupdevices/light.rst:17 ../../pupdevices/pfmotor.rst:35
#: ../../pupdevices/remote.rst:21 ../../pupdevices/tiltsensor.rst:15
#: ../../pupdevices/ultrasonicsensor.rst:26
msgid "Examples"
msgstr "サンプルコード"

#: ../../pupdevices/colordistancesensor.rst:38
msgid "Measuring color"
msgstr "色の計測"

#: ../../pupdevices/colordistancesensor.rst:40
msgid ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"while True:\n"
"    # Read the color.\n"
"    color = sensor.color()\n"
"\n"
"    # Print the measured color.\n"
"    print(color)\n"
"\n"
"    # Move the sensor around and see how\n"
"    # well you can detect colors.\n"
"\n"
"    # Wait so we can read the value.\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"while True:\n"
"    # 色を読み取る。\n"
"    color = sensor.color()\n"
"\n"
"    # 計測した色を表示。\n"
"    print(color)\n"
"\n"
"    # センサーを動かして、どれだけ色を検出できるか\n"
"    # 試してみてください。\n"
"\n"
"    # 値が読み取れたか分かるよう、少し待機。\n"
"    wait(100)\n"

#: ../../pupdevices/colordistancesensor.rst:45
#: ../../pupdevices/colorsensor.rst:46
msgid "Waiting for a color"
msgstr "色の検出の待機"

#: ../../pupdevices/colordistancesensor.rst:47
msgid ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"\n"
"# This is a function that waits for a desired color.\n"
"def wait_for_color(desired_color):\n"
"    # While the color is not the desired color, we keep waiting.\n"
"    while sensor.color() != desired_color:\n"
"        wait(20)\n"
"\n"
"\n"
"# Now we use the function we just created above.\n"
"while True:\n"
"\n"
"    # Here you can make your train/vehicle go forward.\n"
"\n"
"    print(\"Waiting for red ...\")\n"
"    wait_for_color(Color.RED)\n"
"\n"
"    # Here you can make your train/vehicle go backward.\n"
"\n"
"    print(\"Waiting for blue ...\")\n"
"    wait_for_color(Color.BLUE)\n"
msgstr ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"\n"
"# 希望する色を待ち受ける関数。\n"
"def wait_for_color(desired_color):\n"
"    # 希望の色でなければ、待ち続ける。\n"
"    while sensor.color() != desired_color:\n"
"        wait(20)\n"
"\n"
"\n"
"# ここで、先に作成した関数を使う。\n"
"while True:\n"
"\n"
"    # ここで、列車/車両を前進させたりする。\n"
"\n"
"    print(\"Waiting for red ...\")\n"
"    wait_for_color(Color.RED)\n"
"\n"
"    # ここで、列車や車両を後進させたりする。\n"
"\n"
"    print(\"Waiting for blue ...\")\n"
"    wait_for_color(Color.BLUE)\n"

#: ../../pupdevices/colordistancesensor.rst:51
msgid "Measuring distance and blinking the light"
msgstr "距離の計測とライトの点滅"

#: ../../pupdevices/colordistancesensor.rst:53
msgid ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"# Repeat forever.\n"
"while True:\n"
"\n"
"    # If the sensor sees an object nearby.\n"
"    if sensor.distance() <= 40:\n"
"\n"
"        # Then blink the light red/blue 5 times.\n"
"        for i in range(5):\n"
"            sensor.light.on(Color.RED)\n"
"            wait(30)\n"
"            sensor.light.on(Color.BLUE)\n"
"            wait(30)\n"
"    else:\n"
"        # If the sensor sees nothing\n"
"        # nearby, just wait briefly.\n"
"        wait(10)\n"
msgstr ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"# 永久ループ。\n"
"while True:\n"
"\n"
"    # センサーが近くに物体を発見した場合。\n"
"    if sensor.distance() <= 40:\n"
"\n"
"        # 発見すると、ランプを赤/青に5回点滅させる。\n"
"        for i in range(5):\n"
"            sensor.light.on(Color.RED)\n"
"            wait(30)\n"
"            sensor.light.on(Color.BLUE)\n"
"            wait(30)\n"
"    else:\n"
"        # センサーが近くに何もないことを確認したら、\n"
"        # 少しだけ待機する。\n"
"        wait(10)\n"

#: ../../pupdevices/colordistancesensor.rst:57
msgid "Reading hue, saturation, value"
msgstr "色相、彩度、明度の読取り"

#: ../../pupdevices/colordistancesensor.rst:59
msgid ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"while True:\n"
"    # The standard color() method always \"rounds\" the\n"
"    # measurement to the nearest \"whole\" color.\n"
"    # That's useful for most applications.\n"
"\n"
"    # But you can get the original hue, saturation,\n"
"    # and value without \"rounding\", as follows:\n"
"    color = sensor.hsv()\n"
"\n"
"    # Print the results.\n"
"    print(color)\n"
"\n"
"    # Wait so we can read the value.\n"
"    wait(500)\n"
msgstr ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"while True:\n"
"    # 標準の color() メソッドは、計測値を常に\n"
"    #「全色」のうちの最も近い色に「丸める」。\n"
"\n"
"    # しかし、以下のようにすれば、「丸め」なしで元の色相、\n"
"    # 彩度、明度を得られます。\n"
"    color = sensor.hsv()\n"
"\n"
"    # 結果を表示。\n"
"    print(color)\n"
"\n"
"    # 値が読み取れたか分かるよう待機。\n"
"    wait(500)\n"

#: ../../pupdevices/colordistancesensor.rst:63
#: ../../pupdevices/colorsensor.rst:60
msgid "Changing the detectable colors"
msgstr "検出可能な色の変更"

#: ../../pupdevices/colordistancesensor.rst:65
#: ../../pupdevices/colorsensor.rst:62
msgid ""
"By default, the sensor is configured to detect red, yellow, green, blue, "
"white, or no color, which suits many applications."
msgstr ""
"デフォルトでは、センサーは赤、黄、緑、青、白、または無色を検出するように設定されており、"
"多くのアプリケーションに適合しています。"

#: ../../pupdevices/colordistancesensor.rst:68
#: ../../pupdevices/colorsensor.rst:65
msgid ""
"For better results in your application, you can measure your desired "
"colors in advance, and tell the sensor to look only for those colors. Be "
"sure to measure them at the **same distance and light conditions** as in "
"your final application. Then you'll get very accurate results even for "
"colors that are otherwise hard to detect."
msgstr ""
"より良い結果を得るためには、事前に希望の色を測定し、その色だけを探すようにセンサーに"
"指示できます。その際、必ず最終的なアプリケーションと同じ距離と光の条件で測定して"
"ください。そのようにすれば、検出が困難な色でも、非常に正確な結果が得られます。"

#: ../../pupdevices/colordistancesensor.rst:74
msgid ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"# First, decide which objects you want to detect, and measure their HSV "
"values.\n"
"# You can do that with the hsv() method as shown in the previous example."
"\n"
"#\n"
"# Use your measurements to override the default colors, or add new "
"colors:\n"
"Color.GREEN = Color(h=132, s=94, v=26)\n"
"Color.MAGENTA = Color(h=348, s=96, v=40)\n"
"Color.BROWN = Color(h=17, s=78, v=15)\n"
"Color.RED = Color(h=359, s=97, v=39)\n"
"\n"
"# Put your colors in a list or tuple.\n"
"my_colors = (Color.GREEN, Color.MAGENTA, Color.BROWN, Color.RED, "
"Color.NONE)\n"
"\n"
"# Save your colors.\n"
"sensor.detectable_colors(my_colors)\n"
"\n"
"# color() works as usual, but now it returns one of your specified "
"colors.\n"
"while True:\n"
"    color = sensor.color()\n"
"\n"
"    # Print the color.\n"
"    print(color)\n"
"\n"
"    # Check which one it is.\n"
"    if color == Color.MAGENTA:\n"
"        print(\"It works!\")\n"
"\n"
"    # Wait so we can read it.\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import ColorDistanceSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorDistanceSensor(Port.A)\n"
"\n"
"# まず、検出したい物体を決めて、その HSV 値を測定する。\n"
"# これは先ほどの例のようにhsv()メソッドで可能。\n"
"#\n"
"# その測定結果をもとに、デフォルトの色を上書きや、新しい色の追加を行う。\n"
"Color.GREEN = Color(h=132, s=94, v=26)\n"
"Color.MAGENTA = Color(h=348, s=96, v=40)\n"
"Color.BROWN = Color(h=17, s=78, v=15)\n"
"Color.RED = Color(h=359, s=97, v=39)\n"
"\n"
"# リストやタプルに検出する色を指定。\n"
"my_colors = (Color.GREEN, Color.MAGENTA, Color.BROWN, Color.RED, "
"Color.NONE)\n"
"\n"
"# 検出する色を設定。\n"
"sensor.detectable_colors(my_colors)\n"
"\n"
"# 普通どおり color() を使うが、指定した色のどれかを返すようになっている。\n"
"while True:\n"
"    color = sensor.color()\n"
"\n"
"    # 色を表示。\n"
"    print(color)\n"
"\n"
"    # どの色かチェック。\n"
"    if color == Color.MAGENTA:\n"
"        print(\"It works!\")\n"
"\n"
"    # 値が読み取れたか分かるよう待機。\n"
"    wait(100)\n"

#: ../../pupdevices/colorlightmatrix.rst:4
msgid "Color Light Matrix"
msgstr "カラー・ライトマトリクス"

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/diagrams/sensor_colorlightmatrix.png"
msgstr ""

#: of pybricks.pupdevices.ColorLightMatrix:1
msgid "LEGO® SPIKE 3x3 Color Light Matrix."
msgstr "LEGO® SPIKE 3x3 カラー・ライトマトリクス。"

#: of pybricks.pupdevices.ColorLightMatrix:3 pybricks.pupdevices.Light:3
msgid "Port to which the device is connected."
msgstr "デバイスが接続されているポート。"

#: of pybricks.pupdevices.ColorLightMatrix.on:1
msgid "Turns the lights on."
msgstr "ライトを点灯します。"

#: of pybricks.pupdevices.ColorLightMatrix.on:3
msgid ""
"If a single :class:`.Color` is given, then all 9 lights are set to that "
"color. If a list of colors is given, then each light is set to that "
"color."
msgstr ""
"単一の :class:`.Color` が指定された場合、9つのライトはすべてそのカラーに設定されます。"
"色のリストが指定された場合、各ライトはその色に設定されます。"

#: of pybricks.pupdevices.ColorLightMatrix.off:1
msgid "Turns all lights off."
msgstr "すべてのライトを消灯します。"

#: ../../pupdevices/colorsensor.rst:4
msgid "Color Sensor"
msgstr "カラーセンサー"

msgid ".. image:: ../main/diagrams/sensor_color_lights.png"
msgstr ""

#: of pybricks.pupdevices.ColorSensor:1 pybricks.pupdevices.UltrasonicSensor:1
msgid "LEGO® SPIKE Color Sensor."
msgstr "LEGO® SPIKE カラーセンサー"

#: of pybricks._common.AmbientColorSensor.color:1
#: pybricks._common.AmbientColorSensor.hsv:1
msgid "Scans the color of a surface or an external light source."
msgstr "表面または外部光源の色をスキャンします。"

#: of pybricks._common.AmbientColorSensor.color:8
#: pybricks._common.AmbientColorSensor.hsv:7
msgid ""
"Choose ``true`` to scan the color of objects and surfaces. Choose "
"``false`` to scan the color of screens and other external light sources."
msgstr ""
"物体や表面の色をスキャンするには ``True`` を指定します。"
"スクリーンやその他の外部光源の色をスキャンする場合は ``False`` を指定します。"

#: of pybricks._common.AmbientColorSensor.color:13
msgid "Detected color.`"
msgstr "検出した色"

#: ../../pupdevices/colorsensor.rst:19
msgid "Advanced color sensing"
msgstr "高度な色感知"

#: ../../pupdevices/colorsensor.rst:25 ../../pupdevices/ultrasonicsensor.rst:17
msgid "Built-in lights"
msgstr "内蔵ライト"

#: ../../pupdevices/colorsensor.rst:26
msgid ""
"This sensor has 3 built-in lights. You can adjust the brightness of each "
"light. If you use the sensor to measure something, the lights will be "
"turned on or off as needed for the measurement."
msgstr ""
"このセンサーは3つのライトを内蔵しています。それぞれのライトの明るさを調整できます。"
"センサーを使って何かを測定する場合、測定に必要なライトの点灯・消灯が行われます。"

#: of pybricks._common.LightArray3.on:1 pybricks._common.LightArray4.on:1
msgid "Turns on the lights at the specified brightness."
msgstr "指定した明るさでライトを点灯します。"

#: of pybricks._common.LightArray3.on:3
msgid ""
"Use a single value to set the brightness of all lights at the same time. "
"Use a tuple of three values to set the brightness of each light "
"individually."
msgstr ""
"すべてのライトの明るさを1つの値(%)で同時に設定します。"
"各ライトの明るさを個別に設定するには、3つの値のタプルを使います。

#: of pybricks._common.LightArray3.off:1
msgid "Turns off all the lights."
msgstr "すべてのライトを消灯します。"

#: ../../pupdevices/colorsensor.rst:39
msgid "Measuring color and reflection"
msgstr "色と反射光の計測"

#: ../../pupdevices/colorsensor.rst:41
msgid ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"while True:\n"
"    # Read the color and reflection\n"
"    color = sensor.color()\n"
"    reflection = sensor.reflection()\n"
"\n"
"    # Print the measured color and reflection.\n"
"    print(color, reflection)\n"
"\n"
"    # Move the sensor around and see how\n"
"    # well you can detect colors.\n"
"\n"
"    # Wait so we can read the value.\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"while True:\n"
"    # 色と反射光を読み取る。\n"
"    color = sensor.color()\n"
"    reflection = sensor.reflection()\n"
"\n"
"    # 計測した色をと反射光を表示。\n"
"    print(color, reflection)\n"
"\n"
"    # センサーを動かして、どれだけ色を検出できるか\n"
"    # 試してみてください。\n"
"\n"
"    # 値が読み取れたか分かるよう、少し待機。\n"
"    wait(100)\n"

#: ../../pupdevices/colorsensor.rst:48
msgid ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"\n"
"# This is a function that waits for a desired color.\n"
"def wait_for_color(desired_color):\n"
"    # While the color is not the desired color, we keep waiting.\n"
"    while sensor.color() != desired_color:\n"
"        wait(20)\n"
"\n"
"\n"
"# Now we use the function we just created above.\n"
"while True:\n"
"\n"
"    # Here you can make your train/vehicle go forward.\n"
"\n"
"    print(\"Waiting for red ...\")\n"
"    wait_for_color(Color.RED)\n"
"\n"
"    # Here you can make your train/vehicle go backward.\n"
"\n"
"    print(\"Waiting for blue ...\")\n"
"    wait_for_color(Color.BLUE)\n"
msgstr ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"\n"
"# 希望する色を待ち受ける関数。\n"
"def wait_for_color(desired_color):\n"
"    # 希望の色でなければ、待ち続ける。\n"
"    while sensor.color() != desired_color:\n"
"        wait(20)\n"
"\n"
"\n"
"# ここで、先に作成した関数を使う。\n"
"while True:\n"
"\n"
"    # ここで、列車/車両を前進させたりする。\n"
"\n"
"    print(\"Waiting for red ...\")\n"
"    wait_for_color(Color.RED)\n"
"\n"
"    # ここで、列車や車両を後進させたりする。\n"
"\n"
"    print(\"Waiting for blue ...\")\n"
"    wait_for_color(Color.BLUE)\n"

#: ../../pupdevices/colorsensor.rst:53
msgid "Reading *reflected* hue, saturation, and value"
msgstr "*反射光* の色相、彩度、明度の読取り"

#: ../../pupdevices/colorsensor.rst:55
msgid ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"while True:\n"
"    # The standard color() method always \"rounds\" the\n"
"    # measurement to the nearest \"whole\" color.\n"
"    # That's useful for most applications.\n"
"\n"
"    # But you can get the original hue, saturation,\n"
"    # and value without \"rounding\", as follows:\n"
"    color = sensor.hsv()\n"
"\n"
"    # Print the results.\n"
"    print(color)\n"
"\n"
"    # Wait so we can read the value.\n"
"    wait(500)\n"
msgstr ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"while True:\n"
"    # 標準の color() メソッドは、計測値を常に\n"
"    #「全色」のうちの最も近い色に「丸める」。\n"
"    # これはほとんどのアプリケーションで有用。\n"
"\n"
"    # しかし、以下のようにすれば、「丸め」なしで元の色相、\n"
"    # 彩度、明度を得られる。\n"
"    color = sensor.hsv()\n"
"\n"
"    # 結果を表示。\n"
"    print(color)\n"
"\n"
"    # 値が読み取れたか分かるよう待機。\n"
"    wait(500)\n"

#: ../../pupdevices/colorsensor.rst:71
msgid ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"# First, decide which objects you want to detect, and measure their HSV "
"values.\n"
"# You can do that with the hsv() method as shown in the previous example."
"\n"
"#\n"
"# Use your measurements to override the default colors, or add new "
"colors:\n"
"Color.GREEN = Color(h=132, s=94, v=26)\n"
"Color.MAGENTA = Color(h=348, s=96, v=40)\n"
"Color.BROWN = Color(h=17, s=78, v=15)\n"
"Color.RED = Color(h=359, s=97, v=39)\n"
"\n"
"# Put your colors in a list or tuple.\n"
"my_colors = (Color.GREEN, Color.MAGENTA, Color.BROWN, Color.RED, "
"Color.NONE)\n"
"\n"
"# Save your colors.\n"
"sensor.detectable_colors(my_colors)\n"
"\n"
"# color() works as usual, but now it returns one of your specified "
"colors.\n"
"while True:\n"
"    color = sensor.color()\n"
"\n"
"    # Print the color.\n"
"    print(color)\n"
"\n"
"    # Check which one it is.\n"
"    if color == Color.MAGENTA:\n"
"        print(\"It works!\")\n"
"\n"
"    # Wait so we can read it.\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"# まず、検出したい物体を決めて、その HSV 値を計測。\n"
"# これは先ほどの例のように、hsv() メソッドで行える。\n"
"#\n"
"# 測定結果をもとに、デフォルトの色を上書きしたり、新しい色を追加したりする。\n"
"Color.GREEN = Color(h=132, s=94, v=26)\n"
"Color.MAGENTA = Color(h=348, s=96, v=40)\n"
"Color.BROWN = Color(h=17, s=78, v=15)\n"
"Color.RED = Color(h=359, s=97, v=39)\n"
"\n"
"# 定義した色をリストやタプルに指定。\n"
"my_colors = (Color.GREEN, Color.MAGENTA, Color.BROWN, Color.RED, "
"Color.NONE)\n"
"\n"
"# 検出する色を設定。\n"
"sensor.detectable_colors(my_colors)\n"
"\n"
"# 普通どおり color() を使うが、指定した色のどれかを返すようになっている。\n"
"while True:\n"
"    color = sensor.color()\n"
"\n"
"    # 色を表示。\n"
"    print(color)\n"
"\n"
"    # どの色かチェック。\n"
"    if color == Color.MAGENTA:\n"
"        print(\"It works!\")\n"
"\n"
"    # 値が読み取れたか分かるよう待機。\n"
"    wait(100)\n"

#: ../../pupdevices/colorsensor.rst:75
msgid "Reading *ambient* hue, saturation, value, and color"
msgstr "*周囲光* の色相、彩度、明度の読取り"

#: ../../pupdevices/colorsensor.rst:77
msgid ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"# Repeat forever.\n"
"while True:\n"
"\n"
"    # Get the ambient color values. Instead of scanning the color of a "
"surface,\n"
"    # this lets you scan the color of light sources like lamps or "
"screens.\n"
"    hsv = sensor.hsv(surface=False)\n"
"    color = sensor.color(surface=False)\n"
"\n"
"    # Get the ambient light intensity.\n"
"    ambient = sensor.ambient()\n"
"\n"
"    # Print the measurements.\n"
"    print(hsv, color, ambient)\n"
"\n"
"    # Point the sensor at a computer screen or colored light. Watch the "
"color.\n"
"    # Also, cover the sensor with your hands and watch the ambient value."
"\n"
"\n"
"    # Wait so we can read the printed line\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"# 永久ループ。\n"
"while True:\n"
"\n"
"    # 周囲色の値を取得します。表面の色をスキャンする代わりに、\n"
"    # ランプやスクリーンなどの光源の色をスキャンできる。\n"
"    hsv = sensor.hsv(surface=False)\n"
"    color = sensor.color(surface=False)\n"
"\n"
"    # 周囲光の強さを取得します。\n"
"    ambient = sensor.ambient()\n"
"\n"
"    # 計測結果を表示。\n"
"    print(hsv, color, ambient)\n"
"\n"
"    # センサーをコンピューターの画面や色のついた光に向ける。色を観察してください。\n"
"    # また、センサーを手で覆い、周囲の値を観察してください。\n"
"\n"
"    # 何が表示されているかが分かるよう、少し待機。\n"
"    wait(100)\n"

#: ../../pupdevices/colorsensor.rst:81
msgid "Blinking the built-in lights"
msgstr "内蔵ライトの点滅"

#: ../../pupdevices/colorsensor.rst:83
msgid ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"# Repeat forever.\n"
"while True:\n"
"\n"
"    # Turn on one light at a time, at half the brightness.\n"
"    # Do this for all 3 lights and repeat that 5 times.\n"
"    for i in range(5):\n"
"        sensor.lights.on([50, 0, 0])\n"
"        wait(100)\n"
"        sensor.lights.on([0, 50, 0])\n"
"        wait(100)\n"
"        sensor.lights.on([0, 0, 50])\n"
"        wait(100)\n"
"\n"
"    # Turn all lights on at maximum brightness.\n"
"    sensor.lights.on(100)\n"
"    wait(500)\n"
"\n"
"    # Turn all lights off.\n"
"    sensor.lights.off()\n"
"    wait(500)\n"
msgstr ""
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"# 永久ループ。\n"
"while True:\n"
"\n"
"    # 1灯ずつ、半分の明るさで点灯させる。\n"
"    # これを3つの照明すべてに行い、それを5回繰り返す。\n"
"    for i in range(5):\n"
"        sensor.lights.on([50, 0, 0])\n"
"        wait(100)\n"
"        sensor.lights.on([0, 50, 0])\n"
"        wait(100)\n"
"        sensor.lights.on([0, 0, 50])\n"
"        wait(100)\n"
"\n"
"    # すべてのライトを最大照度で点灯させる。\n"
"    sensor.lights.on(100)\n"
"    wait(500)\n"
"\n"
"    # すべてのライトを消灯する。\n"
"    sensor.lights.off()\n"
"    wait(500)\n"

#: ../../pupdevices/colorsensor.rst:87
msgid "Turning off the lights when the program ends"
msgstr "プログラム終了時の消灯"

#: ../../pupdevices/colorsensor.rst:89
msgid ""
"from pybricks.parameters import Port\n"
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"\n"
"def main():\n"
"    # Run the main code.\n"
"    while True:\n"
"        print(sensor.color())\n"
"        wait(500)\n"
"\n"
"\n"
"# Wrap the main code in try/finally so that the cleanup code always runs\n"
"# when the program ends, even if an exception was raised.\n"
"try:\n"
"    main()\n"
"finally:\n"
"    # The cleanup code goes here.\n"
"    print(\"Cleaning up.\")\n"
"    sensor.lights.off()\n"
msgstr ""
"from pybricks.parameters import Port\n"
"from pybricks.pupdevices import ColorSensor\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorSensor(Port.A)\n"
"\n"
"\n"
"def main():\n"
"    # メインコードを実行。\n"
"    while True:\n"
"        print(sensor.color())\n"
"        wait(500)\n"
"\n"
"\n"
"# 例外が発生しても、プログラム終了時に必ずクリーンアップコードが実行されるように、\n"
"# メインコードを try/finally で囲む。\n"
"try:\n"
"    main()\n"
"finally:\n"
"    # ここでクリーンアップコードを実行。\n"
"    print(\"Cleaning up.\")\n"
"    sensor.lights.off()\n"

#: ../../pupdevices/dcmotor.rst:4
msgid "Motors without rotation sensors"
msgstr "回転センサーなしモーター"

#: ../../pupdevices/dcmotor.rst:13 ../../pupdevices/motor.rst:12
msgid "pupmotors"
msgstr ""

#: ../../pupdevices/dcmotor.rst:13
msgid ".. image:: ../main/diagrams/pupdcmotors.png"
msgstr ""

#: ../../pupdevices/dcmotor.rst:13
msgid ""
"Powered Up motors without rotation sensors. The arrows indicate the "
"default positive direction."
msgstr ""
"Powered Up 回転センサーなしモーター。"
"矢印はデフォルトの正方向を示しています。"

#: of pybricks.pupdevices.DCMotor:1
msgid "LEGO® Powered Up motor without rotation sensors."
msgstr "LEGO® Powered Up 回転センサーなしモーター。"

#: of pybricks.pupdevices.DCMotor:3 pybricks.pupdevices.Motor:3
msgid "Port to which the motor is connected."
msgstr "モーターが接続されているポート。"

#: of pybricks.pupdevices.DCMotor:5 pybricks.pupdevices.PFMotor:12
msgid ""
"Which direction the motor should turn when you give a positive duty cycle"
" value."
msgstr ""
"正のデューティ比の値を与えたとき、モーターがどの方向に回転すべきかを示します。"

#: of pybricks._common.DCMotor.dc:1
msgid "Rotates the motor at a given duty cycle (also known as \"power\")."
msgstr "指定のデューティ比(「パワー」とも言います）でモーターを回転させます。"

#: of pybricks._common.DCMotor.dc:3
msgid "The duty cycle (-100.0 to 100)."
msgstr "デューティ比 (-100.0 から 100 の間)。"

#: of pybricks._common.DCMotor.stop:1
msgid "Stops the motor and lets it spin freely."
msgstr "モーターを停止し、惰性で回転するままにします。"

#: of pybricks._common.DCMotor.stop:3
msgid "The motor gradually stops due to friction."
msgstr "モーターは摩擦により徐々に停止します。"

#: of pybricks._common.DCMotor.brake:1
msgid "Passively brakes the motor."
msgstr "モータに受動的にブレーキをかけます。"

#: of pybricks._common.DCMotor.brake:3
msgid ""
"The motor stops due to friction, plus the voltage that is generated while"
" the motor is still moving."
msgstr ""
"摩擦による停止に加え、モータが動いている間に発生した電圧で停止します。"

#: of pybricks._common.DCMotor.settings:1
msgid ""
"Configures motor settings. If no arguments are given, this returns the "
"current values."
msgstr ""
"モータの設定を行います。"
"引数を与えない場合は、現在の値を返します。"

#: of pybricks._common.DCMotor.settings:4
msgid "Maximum voltage applied to the motor during all motor commands."
msgstr "すべてのモーターコマンドの間、モーターにかかる最大電圧。"

#: ../../pupdevices/dcmotor.rst:35
msgid "Making a train drive forever"
msgstr "トレインを動かし続ける"

#: ../../pupdevices/dcmotor.rst:37
msgid ""
"from pybricks.pupdevices import DCMotor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the motor.\n"
"train_motor = DCMotor(Port.A)\n"
"\n"
"# Choose the \"power\" level for your train. Negative means reverse.\n"
"train_motor.dc(50)\n"
"\n"
"# Keep doing nothing. The train just keeps going.\n"
"while True:\n"
"    wait(1000)\n"
msgstr ""
"from pybricks.pupdevices import DCMotor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# モーターを初期化。\n"
"train_motor = DCMotor(Port.A)\n"
"\n"
"# トレインの「電圧」レベルを指定。負の値は逆方向を意味する。\n"
"train_motor.dc(50)\n"
"\n"
"# 何もしない状態を維持。トレインはひたすら走り続ける。\n"
"while True:\n"
"    wait(1000)\n"

#: ../../pupdevices/dcmotor.rst:41 ../../pupdevices/motor.rst:108
msgid "Making the motor move back and forth"
msgstr "モーターを前後に動作"

#: ../../pupdevices/dcmotor.rst:43
#, python-format
msgid ""
"from pybricks.pupdevices import DCMotor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor without rotation sensors on port A.\n"
"example_motor = DCMotor(Port.A)\n"
"\n"
"# Make the motor go clockwise (forward) at 70% duty cycle (\"70% "
"power\").\n"
"example_motor.dc(70)\n"
"\n"
"# Wait for three seconds.\n"
"wait(3000)\n"
"\n"
"# Make the motor go counterclockwise (backward) at 70% duty cycle.\n"
"example_motor.dc(-70)\n"
"\n"
"# Wait for three seconds.\n"
"wait(3000)\n"
msgstr ""
"from pybricks.pupdevices import DCMotor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだ回転センサーなしモーターを初期化。\n"
"example_motor = DCMotor(Port.A)\n"
"\n"
"# 70%のデューティ比(「70%の電圧」)でモーターを時計回り(正転)に回転させる。\n"
"example_motor.dc(70)\n"
"\n"
"# 3秒待機。\n"
"wait(3000)\n"
"\n"
"# 70%のデューティ比(「70%の電圧」)でモーターを反時計回り(後転)に回転させる。\n"
"example_motor.dc(-70)\n"
"\n"
"# 3秒待機。\n"
"wait(3000)\n"

#: ../../pupdevices/dcmotor.rst:47
msgid "Changing the positive direction"
msgstr "正方向の変更"

#: ../../pupdevices/dcmotor.rst:49
msgid ""
"from pybricks.pupdevices import DCMotor\n"
"from pybricks.parameters import Port, Direction\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor without rotation sensors on port A,\n"
"# with the positive direction as counterclockwise.\n"
"example_motor = DCMotor(Port.A, Direction.COUNTERCLOCKWISE)\n"
"\n"
"# When we choose a positive duty cycle, the motor now goes "
"counterclockwise.\n"
"example_motor.dc(70)\n"
"\n"
"# This is useful when your (train) motor is mounted in reverse or upside "
"down.\n"
"# By changing the positive direction, your script will be easier to read,"
"\n"
"# because a positive value now makes your train/robot go forward.\n"
"\n"
"# Wait for three seconds.\n"
"wait(3000)\n"
msgstr ""
"from pybricks.pupdevices import DCMotor\n"
"from pybricks.parameters import Port, Direction\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターについて、反時計回りを正方向を\n"
"# とするように初期化。\n"
"example_motor = DCMotor(Port.A, Direction.COUNTERCLOCKWISE)\n"
"\n"
"# 正の速度値を指定すると、モータは今度は反時計回りに回転。\n"
"example_motor.dc(70)\n"
"\n"
"# これは、モーター(トレイン)が逆向きに取り付けられている場合や、逆さまに取り付け\n"
"# られている場合に有効です。正方向を変更することで、正の速度値でトレインやロボットが\n"
"# 前進するようになり、スクリプトが読みやすくなります。\n"
"\n"
"# 3秒待機。\n"
"wait(3000)\n"

#: ../../pupdevices/dcmotor.rst:53
msgid "Starting and stopping"
msgstr "始動と停止"

#: ../../pupdevices/dcmotor.rst:55
msgid ""
"from pybricks.pupdevices import DCMotor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor without rotation sensors on port A.\n"
"example_motor = DCMotor(Port.A)\n"
"\n"
"# Start and stop 10 times.\n"
"for count in range(10):\n"
"    print(\"Counter:\", count)\n"
"\n"
"    example_motor.dc(70)\n"
"    wait(1000)\n"
"\n"
"    example_motor.stop()\n"
"    wait(1000)\n"
msgstr ""
"from pybricks.pupdevices import DCMotor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターの初期化。\n"
"example_motor = DCMotor(Port.A)\n"
"\n"
"# 始動と停止を10回繰り返す。\n"
"for count in range(10):\n"
"    print(\"Counter:\", count)\n"
"\n"
"    example_motor.dc(70)\n"
"    wait(1000)\n"
"\n"
"    example_motor.stop()\n"
"    wait(1000)\n"

#: ../../pupdevices/forcesensor.rst:4
msgid "Force Sensor"
msgstr "フォースセンサー"

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-force.png"
msgstr ""

#: of pybricks.pupdevices.ForceSensor:1
msgid "LEGO® SPIKE Force Sensor."
msgstr "LEGO® SPIKE フォースセンサー"

#: of pybricks.pupdevices.ForceSensor.force:1
msgid "Measures the force exerted on the sensor."
msgstr "センサーにかかる圧力を計測します。"

#: of pybricks.pupdevices.ForceSensor.force:3
msgid "Measured force (up to approximately 10.00 N)."
msgstr "計測された圧力(最大約 10.00 N)。"

#: of pybricks.pupdevices.ForceSensor.distance:1
msgid "Measures by how much the sensor button has moved."
msgstr "センサーのボタンがどれだけ動いたか計測します。"

#: of pybricks.pupdevices.ForceSensor.distance:3
msgid "Movement up to approximately 8.00 mm."
msgstr "約 8.00 mm までの移動量。"

#: of pybricks.pupdevices.ForceSensor.pressed:1
msgid "Checks if the sensor button is pressed."
msgstr "センサーボタンが押されたかどうかをチェックする。"

#: of pybricks.pupdevices.ForceSensor.pressed:3
msgid "Minimum force to be considered pressed."
msgstr "押されていると判断できる最小の力。"

#: of pybricks.pupdevices.ForceSensor.pressed:6
msgid "``True`` if the sensor is pressed, ``False`` if it is not."
msgstr "センサーが押されていれば ``True`` 、押されていなければ ``False`` 。"

#: of pybricks.pupdevices.ForceSensor.touched:1
msgid "Checks if the sensor is touched."
msgstr "センサーがタッチされたかどうかをチェックします。"

#: of pybricks.pupdevices.ForceSensor.touched:3
msgid ""
"This is similar to :meth:`pressed`, but it detects slight movements of "
"the button even when the measured force is still considered zero."
msgstr ""
":meth:`pressed` と似ていますが、計測した圧力がゼロのままでも、"
"ボタンがわずかに動いたことを検出します。"

#: of pybricks.pupdevices.ForceSensor.touched:6
msgid "``True`` if the sensor is touched or pressed, ``False`` if it is not."
msgstr "センサーに触れたり押されたりした場合は ``True`` 、そうでない場合は ``False`` 。"

#: ../../pupdevices/forcesensor.rst:24
msgid "Measuring force and movement"
msgstr "圧力と移動の計測"

#: ../../pupdevices/forcesensor.rst:26
msgid ""
"from pybricks.pupdevices import ForceSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"button = ForceSensor(Port.A)\n"
"\n"
"while True:\n"
"    # Read all the information we can get from this sensor.\n"
"    force = button.force()\n"
"    dist = button.distance()\n"
"    press = button.pressed()\n"
"    touch = button.touched()\n"
"\n"
"    # Print the values\n"
"    print(\"Force\", force, \"Dist:\", dist, \"Pressed:\", press, "
"\"Touched:\", touch)\n"
"\n"
"    # Push the sensor button see what happens to the values.\n"
"\n"
"    # Wait some time so we can read what is printed.\n"
"    wait(200)\n"
msgstr ""
"from pybricks.pupdevices import ForceSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"button = ForceSensor(Port.A)\n"
"\n"
"while True:\n"
"    # このセンサーから得られる情報をすべて読み取る。\n"
"    force = button.force()\n"
"    dist = button.distance()\n"
"    press = button.pressed()\n"
"    touch = button.touched()\n"
"\n"
"    # 値を表示\n"
"    print(\"Force\", force, \"Dist:\", dist, \"Pressed:\", press, "
"\"Touched:\", touch)\n"
"\n"
"    # センサーボタンを押して、値がどうなるかを確認する。\n"
"\n"
"    # 何が表示されているかが分かるよう、少し待機。\n"
"    wait(200)\n"

#: ../../pupdevices/forcesensor.rst:30
msgid "Measuring peak force"
msgstr "最大圧力の計測"

#: ../../pupdevices/forcesensor.rst:32
msgid ""
"from pybricks.pupdevices import ForceSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"button = ForceSensor(Port.A)\n"
"\n"
"\n"
"# This function waits until the button is pushed. It keeps track of the "
"maximum\n"
"# detected force until the button is released. Then it returns the "
"maximum.\n"
"def wait_for_force():\n"
"\n"
"    # Wait for a force, by doing nothing for as long the force is nearly "
"zero.\n"
"    print(\"Waiting for force.\")\n"
"    while button.force() <= 0.1:\n"
"        wait(10)\n"
"\n"
"    # Now we wait for the release, by waiting for the force to be zero "
"again.\n"
"    print(\"Waiting for release.\")\n"
"\n"
"    # While we wait for that to happen, we keep reading the force and "
"remember\n"
"    # the maximum force. We do this by initializing the maximum at 0, and"
"\n"
"    # updating it each time we detect a bigger force.\n"
"    maximum = 0\n"
"    force = 10\n"
"    while force > 0.1:\n"
"        # Read the force.\n"
"        force = button.force()\n"
"\n"
"        # Update the maximum if the measured force is larger.\n"
"        if force > maximum:\n"
"            maximum = force\n"
"\n"
"        # Wait and then measure again.\n"
"        wait(10)\n"
"\n"
"    # Return the maximum force.\n"
"    return maximum\n"
"\n"
"\n"
"# Keep waiting for the sensor button to be pushed. When it is, display\n"
"# the peak force and repeat.\n"
"while True:\n"
"    peak = wait_for_force()\n"
"    print(\"Released. Peak force: {0} N\\n\".format(peak))\n"
msgstr ""
"from pybricks.pupdevices import ForceSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"button = ForceSensor(Port.A)\n"
"\n"
"\n"
"# ボタンが押されるまで待機する関数。ボタンが離されるまで、検出された力の最大値を\n"
"# 記録する。そして、その最大値を返す。\n"
"def wait_for_force():\n"
"\n"
"    # 圧力がほぼゼロの間は何もしないで待機。\n"
"    print(\"Waiting for force.\")\n"
"    while button.force() <= 0.1:\n"
"        wait(10)\n"
"\n"
"    # あとは、圧力が再びゼロになるのを待つことで、解放を待つ。\n"
"    print(\"Waiting for release.\")\n"
"\n"
"    # それを待つ間、圧力を読み続け、最大圧力を記憶する。\n"
"    # これは、最大値を0に初期化し、大きな力を検出するたびに\n"
"    # 更新することで行う。\n"
"    maximum = 0\n"
"    force = 10\n"
"    while force > 0.1:\n"
"        # 圧力を読み取る。\n"
"        force = button.force()\n"
"\n"
"        # 計測した圧力の方が大きい場合は、最大値を更新する。\n"
"        if force > maximum:\n"
"            maximum = force\n"
"\n"
"        # 待機したあと、再度計測する。\n"
"        wait(10)\n"
"\n"
"    # 最大圧力を返す。\n"
"    return maximum\n"
"\n"
"\n"
"# センサーボタンが押されるのを待ち続ける。\n"
"# 最大圧力を表示し、それを繰り返す。\n"
"while True:\n"
"    peak = wait_for_force()\n"
"    print(\"Released. Peak force: {0} N\\n\".format(peak))\n"

#: ../../pupdevices/index.rst:4
msgid ":mod:`pupdevices <pybricks.pupdevices>` -- Motors, sensors, lights"
msgstr ":mod:`pupdevices <pybricks.pupdevices>` -- モーター、センサー、ライト"

#: of pybricks.pupdevices:1
msgid "LEGO® Powered Up motor, sensors, and lights."
msgstr "LEGO® Powered Up モーター、センサー、ライト。"

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-dcmotors.png"
msgstr ""

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-motors.png"
msgstr ""

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-tilt.png"
msgstr ""

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-infrared.png"
msgstr ""

#: ../../pupdevices/index.rst ../../pupdevices/pfmotor.rst:15
msgid ".. image:: ../main/cad/output/pupdevice-pfmotor.png"
msgstr ""

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-color.png"
msgstr ""

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-ultrasonic.png"
msgstr ""

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-light.png"
msgstr ""

#: ../../pupdevices/index.rst
msgid ".. image:: ../main/cad/output/pupdevice-remote.png"
msgstr ""

#: ../../pupdevices/infraredsensor.rst:4
msgid "Infrared Sensor"
msgstr "赤外線センサー"

#: of pybricks.pupdevices.InfraredSensor:1
msgid "LEGO® Powered Up Infrared Sensor."
msgstr "LEGO® Powered Up 赤外線センサー"

#: of pybricks.pupdevices.InfraredSensor.reflection:1
msgid "Measures the reflection of a surface using an infrared light."
msgstr "赤外線で表面の反射を計測します。"

#: of pybricks.pupdevices.InfraredSensor.count:1
msgid "Counts the number of objects that have passed by the sensor."
msgstr "センサーを通過した物体の数をカウントします。"

#: of pybricks.pupdevices.InfraredSensor.count:3
msgid "Number of objects counted."
msgstr "カウントした物体の数。"

#: ../../pupdevices/infraredsensor.rst:22
msgid "Measuring distance, object count, and reflection"
msgstr "距離、物体数、反射率の計測"

#: ../../pupdevices/infraredsensor.rst:24
msgid ""
"from pybricks.pupdevices import InfraredSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"ir = InfraredSensor(Port.A)\n"
"\n"
"while True:\n"
"    # Read all the information we can get from this sensor.\n"
"    dist = ir.distance()\n"
"    count = ir.count()\n"
"    ref = ir.reflection()\n"
"\n"
"    # Print the values\n"
"    print(\"Distance:\", dist, \"Count:\", count, \"Reflection:\", ref)\n"
"\n"
"    # Move the sensor around and move your hands in front\n"
"    # of it to see what happens to the values.\n"
"\n"
"    # Wait some time so we can read what is printed.\n"
"    wait(200)\n"
msgstr ""
"from pybricks.pupdevices import InfraredSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"ir = InfraredSensor(Port.A)\n"
"\n"
"while True:\n"
"    # このセンサーから得られる情報をすべて読み取る。\n"
"    dist = ir.distance()\n"
"    count = ir.count()\n"
"    ref = ir.reflection()\n"
"\n"
"    # 値を表示\n"
"    print(\"Distance:\", dist, \"Count:\", count, \"Reflection:\", ref)\n"
"\n"
"    # センサーを動かし、その前で手を動かして、値がどうなるかを\n"
"    # 見てみましょう。\n"
"\n"
"    # 何が表示されているかが分かるよう、少し待機。\n"
"    wait(200)\n"

#: ../../pupdevices/light.rst:4
msgid "Light"
msgstr "ライト"

#: of pybricks.pupdevices.Light:1
msgid "LEGO® Powered Up Light."
msgstr "LEGO® Powered Up ライト。"

#: of pybricks.pupdevices.Light.on:1
msgid "Turns on the light at the specified brightness."
msgstr "ライトを指定の照度で点灯。"

#: of pybricks.pupdevices.Light.on:3
msgid "Brightness of the light."
msgstr "ライトの照度。"

#: ../../pupdevices/light.rst:20
msgid "Making the light blink"
msgstr "ライトを点滅させる"

#: ../../pupdevices/light.rst:22
msgid ""
"from pybricks.pupdevices import Light\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the light.\n"
"light = Light(Port.A)\n"
"\n"
"# Blink the light forever.\n"
"while True:\n"
"    # Turn the light on at 100% brightness.\n"
"    light.on(100)\n"
"    wait(500)\n"
"\n"
"    # Turn the light off.\n"
"    light.off()\n"
"    wait(500)\n"
msgstr ""
"from pybricks.pupdevices import Light\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ライトを初期化。\n"
"light = Light(Port.A)\n"
"\n"
"# ライトを点滅させ続ける。\n"
"while True:\n"
"    # ライトを 100% の照度で点灯。\n"
"    light.on(100)\n"
"    wait(500)\n"
"\n"
"    # ライトを消灯。\n"
"    light.off()\n"
"    wait(500)\n"

#: ../../pupdevices/light.rst:26
msgid "Gradually change the brightness"
msgstr "照度を段階的に変化させる"

#: ../../pupdevices/light.rst:28
msgid ""
"from pybricks.pupdevices import Light\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait, StopWatch\n"
"\n"
"from umath import pi, cos\n"
"\n"
"# Initialize the light and a StopWatch.\n"
"light = Light(Port.A)\n"
"watch = StopWatch()\n"
"\n"
"# Cosine pattern properties.\n"
"PERIOD = 2000\n"
"MAX = 100\n"
"\n"
"# Make the brightness fade in and out.\n"
"while True:\n"
"    # Get phase of the cosine.\n"
"    phase = watch.time() / PERIOD * 2 * pi\n"
"\n"
"    # Evaluate the brightness.\n"
"    brightness = (0.5 - 0.5 * cos(phase)) * MAX\n"
"\n"
"    # Set light brightness and wait a bit.\n"
"    light.on(brightness)\n"
"    wait(10)\n"
msgstr ""
"from pybricks.pupdevices import Light\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait, StopWatch\n"
"\n"
"from umath import pi, cos\n"
"\n"
"# ライトとストップウォッチを初期化。\n"
"light = Light(Port.A)\n"
"watch = StopWatch()\n"
"\n"
"# コサインパターンのプロパティ。\n"
"PERIOD = 2000\n"
"MAX = 100\n"
"\n"
"# 明るさをフェードイン/フェードアウトさせる。\n"
"while True:\n"
"    # コサインの位相を取得。\n"
"    phase = watch.time() / PERIOD * 2 * pi\n"
"\n"
"    # 照度を評価。\n"
"    brightness = (0.5 - 0.5 * cos(phase)) * MAX\n"
"\n"
"    # ライトに照度を設定して、少しだけ待機。\n"
"    light.on(brightness)\n"
"    wait(10)\n"

#: ../../pupdevices/motor.rst:4
msgid "Motors with rotation sensors"
msgstr "回転センサー付モーター"

#: ../../pupdevices/motor.rst:12
msgid ".. image:: ../main/diagrams/pupmotors.png"
msgstr ""

#: ../../pupdevices/motor.rst:12
msgid ""
"Powered Up motors with rotation sensors. The arrows indicate the default "
"positive direction. See the :mod:`hubs <pybricks.hubs>` module for "
"default directions of built-in motors."
msgstr ""
"回転センサー付の Powered Up モーター。矢印はデフォルトの正方向を示します。"
"内蔵モーターのデフォルトの方向については、 :mod:`hubs <pybricks.hubs>` "
"モジュールを参照してください。"

#: of pybricks.pupdevices.Motor:1
msgid "LEGO® Powered Up motor with rotation sensors."
msgstr "LEGO® 回転センサー付の Powered Up モーター。"

#: of pybricks.pupdevices.Motor:5
msgid ""
"Which direction the motor should turn when you give a positive speed "
"value or angle."
msgstr ""
"正の速度値または角度を与えたときに、モーターがどの方向に回転すべきかを指定します。"

#: of pybricks.pupdevices.Motor:9
msgid ""
"List of gears linked to the motor. The gear connected to the motor comes "
"first and the gear connected to the output comes last.  For example: "
"``[12, 36]`` represents a gear train with a 12-tooth gear connected to "
"the motor and a 36-tooth gear connected to the output. Use a list of "
"lists for multiple gear trains, such as ``[[12, 36], [20, 16, 40]]``.  "
"When you specify a gear train, all motor commands and settings are "
"automatically adjusted to account for the resulting gear ratio. The motor"
" direction remains unchanged by this."
msgstr ""
"モーターに接続している歯車のリスト。"
"モーターに直接接続している歯車をリストの最初に指定し、"
"出力側に接続している歯車をリストの最後に指定します。"
"たとえば ``[12, 36]`` は、モーターに直接接続している12歯の歯車と、"
"出力側に接続している36歯の歯車を持つ歯車列を表します。"
"複数の歯車列を扱う際には ``[[12, 36], [20, 16, 40]]`` のように"
"リストのリストを使います。"
"歯車列を指定すると、すべてのモーターコマンドと設定は、結果として生じる歯車比を"
"考慮して自動的に調整されます。モータの方向はこれによって変更されません。"

#: of pybricks.pupdevices.Motor:9
msgid "List of gears linked to the motor."
msgstr "モーターに接続している歯車のリスト。"

#: of pybricks.pupdevices.Motor:11
msgid ""
"For example: ``[12, 36]`` represents a gear train with a 12-tooth gear "
"connected to the motor and a 36-tooth gear connected to the output. Use a"
" list of lists for multiple gear trains, such as ``[[12, 36], [20, 16, "
"40]]``."
msgstr ""
"たとえば ``[12, 36]`` は、モーターに直接接続している12歯の歯車と、"
"出力側に接続している36歯の歯車を持つ歯車列を表します。"
"複数の歯車列を扱う際には ``[[12, 36], [20, 16, 40]]`` のように"
"リストのリストを使います。"

#: of pybricks.pupdevices.Motor:15
msgid ""
"When you specify a gear train, all motor commands and settings are "
"automatically adjusted to account for the resulting gear ratio. The motor"
" direction remains unchanged by this."
msgstr ""
"歯車列を指定すると、すべてのモーターコマンドと設定は、結果として生じる歯車比を"
"考慮して自動的に調整されます。モータの方向はこれによって変更されません。"

#: of pybricks.pupdevices.Motor:19
msgid ""
"Choose ``True`` to reset the rotation sensor value to the absolute marker"
" angle (between -180 and 179). Choose ``False`` to keep the current "
"value, so your program knows where it left off last time."
msgstr ""
"``True`` を指定すると、回転センサーの値が絶対マーカー角(-180 から 179 の間)に"
"リセットされます。 ``False`` を指定すると、現在の値が維持され、プログラムは前回の"
"終了点を知ることができます。"

#: of pybricks.pupdevices.Motor:25
msgid ""
"Precision profile. This is the approximate position tolerance in degrees "
"that is acceptable in your application. A lower value gives more precise "
"but more erratic movement; a higher value gives less precise but smoother"
" movement. If no value is given, a suitable profile for this motor type "
"will be selected automatically (about 11 degrees)."
msgstr ""
"精密プロファイル。これは、あなたのアプリケーションで許容される角度の位置許容差の"
"おおよその値です。低い値はより精密ながら不規則な動きを提供しますが、高い値はより"
"滑らかながら精度の低い動きを提供します。値が指定されていない場合、このモータータイプに"
"適したプロファイルが自動的に選択されます(約11°)。

#: ../../pupdevices/motor.rst:20
msgid "Measuring"
msgstr "計測"

#: of pybricks._common.Motor.angle:1
msgid "Gets the rotation angle of the motor."
msgstr "モーターの回転角を取得します。"

#: of pybricks._common.Motor.angle:3
msgid "Motor angle."
msgstr "モーターの回転角。"

#: of pybricks.pupdevices.Motor.reset_angle:1
msgid "Sets the accumulated rotation angle of the motor to a desired value."
msgstr "モータの累積回転角を任意の値に設定します。"

#: of pybricks.pupdevices.Motor.reset_angle:3
msgid ""
"If you don't specify an angle, the absolute angle will be used if your "
"motor supports it."
msgstr ""
"角度を指定しない場合、モーターが対応していれば絶対角度が適用されます。"

#: of pybricks.pupdevices.Motor.reset_angle:6
msgid "Value to which the angle should be reset."
msgstr "リセットする角度の値。"

#: of pybricks._common.Motor.speed:1
msgid "Gets the speed of the motor."
msgstr "モーターのスピードを取得します。"

#: of pybricks._common.Motor.speed:3
msgid ""
"The speed is measured as the change in the motor angle during the given "
"time window. A short window makes the speed value more responsive to "
"motor movement, but less steady. A long window makes the speed value less"
" responsive, but more steady."
msgstr ""
"速度は、与えられたタイムウィンドウの間のモーター角度の変化として測定されます。"
"ウィンドウを短くすると、速度値はモータの動きに反応しやすくなりますが、"
"安定性は低下します。長いウィンドウを使用すると、速度値はモータの動きに"
"反応しにくくなりますが、より安定した値になります。"

#: of pybricks._common.Motor.speed:8
msgid "The time window used to determine the speed."
msgstr "速度を決定するために使用されるタイムウィンドウ。"

#: of pybricks._common.Motor.speed:11
msgid "Motor speed."
msgstr "モーターのスピード。"

#: of pybricks._common.Motor.load:1
msgid "Estimates the load that holds back the motor when it tries to move."
msgstr "モーターが動こうとしたときに、それを押しとどめる荷重を見積もります。"

#: of pybricks._common.Motor.load:3
msgid "The load torque."
msgstr "負荷トルク。"

#: of pybricks._common.Motor.stalled:1
msgid "Checks if the motor is currently stalled."
msgstr "現在、モータが失速状態なのかを確認します。"

#: of pybricks._common.Motor.stalled:3
msgid ""
"It is stalled when it cannot reach the target speed or position, even "
"with the maximum actuation signal."
msgstr ""
"最大動作信号でも目標速度や位置に到達できない場合、失速していることになります。"

#: of pybricks._common.Motor.stalled:6
msgid "``True`` if the motor is stalled, ``False`` if not."
msgstr "モータが失速している場合は ``True`` 、失速していない場合は ``False`` 。"

#: ../../pupdevices/motor.rst:32
msgid "Stopping"
msgstr "停止"

#: of pybricks._common.Motor.hold:1
msgid "Stops the motor and actively holds it at its current angle."
msgstr "モータを停止し、現在の角度に能動的に維持します。"

#: ../../pupdevices/motor.rst:40
msgid "Running forever"
msgstr "無限動作"

#: of pybricks._common.Motor.run:1
msgid "Runs the motor at a constant speed."
msgstr "モーターを一定速度で回転させます。"

#: of pybricks._common.Motor.run:3
msgid ""
"The motor accelerates to the given speed and keeps running at this speed "
"until you give a new command."
msgstr ""
"指定された速度まで加速し、新たな指令を出すまでこの速度で動き続けます。"

#: of pybricks._common.Motor.run:6 pybricks._common.Motor.run_angle:3
#: pybricks._common.Motor.run_target:6 pybricks._common.Motor.run_time:7
#: pybricks._common.Motor.run_until_stalled:3
msgid "Speed of the motor."
msgstr "モーターの速度。"

#: ../../pupdevices/motor.rst:46
msgid "Running by a fixed amount"
msgstr "一定量の動作"

#: of pybricks._common.Motor.run_time:1
msgid "Runs the motor at a constant speed for a given amount of time."
msgstr "モータを一定速度で一定時間回転させます。"

#: of pybricks._common.Motor.run_time:3
msgid ""
"The motor accelerates to the given speed, keeps running at this speed, "
"and then decelerates. The total maneuver lasts for exactly the given "
"amount of ``time``."
msgstr ""
"与えられた速度まで加速し、その速度で走り続け、その後減速します。"
"全動作は指定した時間(``time``)だけ続きます。"

#: of pybricks._common.Motor.run_time:9
msgid "Duration of the maneuver."
msgstr "動作時間。"

#: of pybricks._common.Motor.run_angle:8 pybricks._common.Motor.run_target:10
#: pybricks._common.Motor.run_time:11
#: pybricks._common.Motor.run_until_stalled:5
msgid "What to do after coming to a standstill."
msgstr "停止した後の挙動。"

#: of pybricks._common.Motor.run_angle:10 pybricks._common.Motor.run_time:13
msgid ""
"Wait for the maneuver to complete before continuing with the rest of the "
"program."
msgstr ""
"動作が完了するのを待ってから、プログラムの続きを実行するのかの指定。"

#: of pybricks._common.Motor.run_angle:1
msgid "Runs the motor at a constant speed by a given angle."
msgstr "モーターを一定速度で指定の角度だけ回転させます。"

#: of pybricks._common.Motor.run_angle:5
msgid "Angle by which the motor should rotate."
msgstr "モーターを回転させる角度。"

#: of pybricks._common.Motor.run_target:1
msgid "Runs the motor at a constant speed towards a given target angle."
msgstr "指定した目標角度に向かって一定速度でモーターを回転させます。"

#: of pybricks._common.Motor.run_target:3
msgid ""
"The direction of rotation is automatically selected based on the target "
"angle. It does not matter if ``speed`` is positive or negative."
msgstr ""
"回転方向は、目標角度に応じて自動的に選択されます。速度(``speed``)は正でも
"負でもかまいません。"

#: of pybricks._common.Motor.run_target:8
msgid "Angle that the motor should rotate to."
msgstr "モーターが回転すべき角度(deg)。"

#: of pybricks._common.Motor.run_target:12
msgid ""
"Wait for the motor to reach the target before continuing with the rest of"
" the program."
msgstr ""
"モーターが目標角度に到達するのを待ってから、残りのプログラムを続行するかの指定。"

#: of pybricks._common.Motor.track_target:1
msgid ""
"Tracks a target angle. This is similar to :meth:`.run_target`, but the "
"usual smooth acceleration is skipped: it will move to the target angle as"
" fast as possible. This method is useful if you want to continuously "
"change the target angle."
msgstr ""
"目標角度を追跡します。"
"これは :meth:`.run_target` と似ていますが、通常の滑らかな加速はスキップし、"
"できるだけ速く目標角度に移動します。"
"この方法は、目標角度を連続的に変化させたい場合に有効です。"

#: of pybricks._common.Motor.track_target:6
msgid "Target angle that the motor should rotate to."
msgstr "モーターが回転すべき目標角度。"

#: of pybricks._common.Motor.run_until_stalled:1
msgid "Runs the motor at a constant speed until it stalls."
msgstr "モータが失速するまで一定速度で動作させます。"

#: of pybricks._common.Motor.run_until_stalled:7
msgid ""
"Duty cycle limit during this command. This is useful to avoid applying "
"the full motor torque to a geared or lever mechanism. If it is ``None``, "
"the duty limit won't be changed during this command."
msgstr ""
"このコマンドの実行中のデューティ比制限値(%)。"
"ギヤ機構やレバー機構にモータトルクをフルにかけないようにする場合に有効です。 "
"``None`` の場合、このコマンド実行中のデューティ制限を変更しません。"

#: of pybricks._common.Motor.run_until_stalled:13
msgid "Angle at which the motor becomes stalled."
msgstr "モーターが失速した角度。"

#: of pybricks._common.Motor.done:1
msgid "Checks if an ongoing command or maneuver is done."
msgstr "実行中のコマンドや操作が完了したかどうかをチェックします。"

#: of pybricks._common.Motor.done:3
msgid "``True`` if the command is done, ``False`` if not."
msgstr "完了した場合は ``True`` 、完了していない場合は ``False`` 。

#: ../../pupdevices/motor.rst:62
msgid "Motor settings"
msgstr "モーターの設定"

#: of pybricks._common.Motor.close:1
msgid ""
"Closes the motor object so you can call ``Motor`` again to initialize a "
"new object."
msgstr ""
"モーターオブジェクトを閉じます。"
"新しいオブジェクトを初期化するには ``Motor`` を再度呼び出す必要があります。"

#: of pybricks._common.Motor.close:4
msgid ""
"This allows advanced users to change properties such as gearing in the "
"middle of the program, which can be useful for removeable attachments."
msgstr ""
"これにより、上級ユーザはプログラムの途中でギアリングなどのプロパティを"
"変更できるようになり、取り外し可能なアタッチメント用に便利です。"

#: ../../pupdevices/motor.rst:66
msgid "Control settings"
msgstr "制御の設定"

#: of pybricks._common.Control.limits:1
msgid "Configures the maximum speed, acceleration, and torque."
msgstr "最大の速度、加速度、トルクを設定します。"

#: of pybricks._common.Control.limits:3 pybricks._common.Control.pid:3
#: pybricks._common.Control.stall_tolerances:3
#: pybricks._common.Control.target_tolerances:3
msgid "If no arguments are given, this will return the current values."
msgstr "引数を指定しない場合は、現在の値を返します。"

#: of pybricks._common.Control.limits:5
msgid ""
"The new ``acceleration`` and ``speed`` limit will become effective when "
"you give a new motor command. Ongoing maneuvers are not affected."
msgstr ""
"新しい加速度(``acceleration``)と速度(``speed``)の制限は、新しいモーターコマンドを"
"入力したときに有効になります。実行中の操作には影響しません。"

#: of pybricks._common.Control.limits:8
msgid "Maximum speed. All speed commands will be capped to this value."
msgstr "最大速度。すべての速度コマンドはこの値に制限されます。"

#: of pybricks._common.Control.limits:10
msgid ""
"Slope of the speed curve when accelerating or decelerating. Use a tuple "
"to set acceleration and deceleration separately. If one value is given, "
"it is used for both."
msgstr ""
"加速または減速時の速度曲線の傾き。"
"加速と減速を別々に設定するには、タプルを使います。"
"1つの値を指定した場合には、加速と減速は両方に適用されます。"

#: of pybricks._common.Control.limits:14
msgid "Maximum feedback torque during control."
msgstr "制御中の最大フィードバックトルク。"

#: of pybricks._common.Control.pid:1
msgid "Gets or sets the PID values for position and speed control."
msgstr "位置および速度制御のためのPID値を取得または設定します。"

#: of pybricks._common.Control.pid:5
msgid ""
"Proportional position control constant. It is the feedback torque per "
"degree of error: µNm/deg."
msgstr ""
"比例位置制御定数。誤差1度あたりのフィードバックトルク: μNm/deg。"

#: of pybricks._common.Control.pid:9
msgid ""
"Integral position control constant. It is the feedback torque per "
"accumulated degree of error: µNm/(deg s)."
msgstr ""
"積分位置制御定数。累積誤差1度あたりのフィードバックトルク: µNm/(deg s)。"

#: of pybricks._common.Control.pid:12
msgid ""
"Derivative position (or proportional speed) control constant. It is the "
"feedback torque per unit of speed: µNm/(deg/s)."
msgstr ""
"微分位置（または比例速度）制御定数。単位速度あたりのフィードバックトルク: µNm/(deg/s)。"

#: of pybricks._common.Control.pid:16
msgid ""
"Zone around the target where the error integral does not accumulate "
"errors."
msgstr ""
"誤差積分がエラーを蓄積しないターゲットまわりのゾーン。"

#: of pybricks._common.Control.pid:19
msgid "Maximum rate at which the error integral is allowed to grow."
msgstr "誤差積分値の最大速度。"

#: of pybricks._common.Control.target_tolerances:1
msgid "Gets or sets the tolerances that say when a maneuver is done."
msgstr "動作がいつ終了するかという公差を取得または設定します。"

#: of pybricks._common.Control.target_tolerances:5
msgid "Allowed deviation from zero speed before motion is considered complete."
msgstr "運動が完了したとみなす速度ゼロからの許容誤差。"

#: of pybricks._common.Control.target_tolerances:8
msgid "Allowed deviation from the target before motion is considered complete."
msgstr "運動が完了したとみなす目標位置からのずれ。"

#: of pybricks._common.Control.stall_tolerances:1
msgid "Gets or sets stalling tolerances."
msgstr "失速の許容値を取得または設定します。"

#: of pybricks._common.Control.stall_tolerances:5
msgid ""
"If the controller cannot reach this speed for some ``time`` even with "
"maximum actuation, it is stalled."
msgstr ""
"コントローラを最大に動作させても、この速度にしばらく到達できない場合、"
"失速となります。"

#: of pybricks._common.Control.stall_tolerances:9
msgid ""
"How long the controller has to be below this minimum ``speed`` before we "
"say it is stalled."
msgstr ""
"コントローラがこの最低速度(``speed``)を下回ってから失速したと言うまでの時間。"

#: ../../pupdevices/motor.rst:87
msgid ""
"Number of degrees that the motor turns to complete one degree at the "
"output of the gear train. This is the gear ratio determined from the "
"``gears`` argument when initializing the motor."
msgstr ""
"ギア列の出力で1度を完成させるためにモータが回転する度数。"
"モータの初期化時に引数 ``gears`` から求めたギア比になります。"

#: ../../pupdevices/motor.rst:93
msgid ""
"The :meth:`done`, :meth:`stalled` and :meth:`load` methods have been "
"moved."
msgstr ""
":meth:`done`, :meth:`stalled`, :meth:`load` メソッドは移されました。"

#: of pybricks._common.Model.state:1
msgid ""
"Gets the estimated angle, speed, current, and stall state of the motor, "
"using a simulation model that mimics the real motor. These estimates are "
"updated faster than the real measurements, which can be useful when "
"building your own PID controllers."
msgstr ""
"実際のモータを模倣したシミュレーションモデルを用いて、モータの角度、速度、電流、"
"失速状態の推定値を取得します。これらの推定値は実際の測定値よりも高速に更新されるため、"
"独自のPIDコントローラを構築する際に有用です。"

#: of pybricks._common.Model.state:6
msgid ""
"For most applications it is better to used the *measured* :meth:`angle "
"<pybricks.pupdevices.Motor.angle>`, :meth:`speed "
"<pybricks.pupdevices.Motor.speed>`, :meth:`load "
"<pybricks.pupdevices.Motor.load>`, and :meth:`stall "
"<pybricks.pupdevices.Motor.stalled>` state instead."
msgstr ""
"ほとんどのアプリケーションでは、代わりに計測した "
":meth:`angle <pybricks.pupdevices.Motor.angle>`, "
":meth:`speed <pybricks.pupdevices.Motor.speed>`, "
":meth:`load <pybricks.pupdevices.Motor.load>`, "
":meth:`stall <pybricks.pupdevices.Motor.stalled>` "
"を使った方がよいでしょう。"

#: of pybricks._common.Model.state:12
msgid ""
"Tuple with the estimated angle (deg), speed (deg/s), current (mA), and "
"stall state (``True`` or ``False``)."
msgstr ""
"推定した角度(deg)、速度(deg/s)、電流(mA)、失速状態を表すタプル。"

#: of pybricks._common.Model.settings:1
msgid ""
"Gets or sets model settings as a tuple of integers. If no arguments are "
"given, this will return the current values. This method is mainly used to"
" debug the motor model class. Changing these settings should not be "
"needed in user programs."
msgstr ""
"モデル設定を整数のタプルとして取得または設定します。引数が与えられていない場合は、"
"現在の値が返されます。このメソッドは主にモーターモデルクラスのデバッグに使われます。"
"ユーザープログラムでは、これらの設定を変更する必要はないはずです。"

#: of pybricks._common.Model.settings:8
msgid "Tuple with `model settings`_."
msgstr "`model settings`_ を持つタプル。"

#: ../../pupdevices/motor.rst:105
msgid "Initialization examples"
msgstr "初期化の例"

#: ../../pupdevices/motor.rst:110
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# Make the motor run clockwise at 500 degrees per second.\n"
"example_motor.run(500)\n"
"\n"
"# Wait for three seconds.\n"
"wait(3000)\n"
"\n"
"# Make the motor run counterclockwise at 500 degrees per second.\n"
"example_motor.run(-500)\n"
"\n"
"# Wait for three seconds.\n"
"wait(3000)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターの初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# モーターを時計回りに 500°/s で動作させる。\n"
"example_motor.run(500)\n"
"\n"
"# ３秒待機。\n"
"wait(3000)\n"
"\n"
"# モーターを反時計回りに 500°/s で動作させる。\n"
"example_motor.run(-500)\n"
"\n"
"# ３秒待機。\n"
"wait(3000)\n"

#: ../../pupdevices/motor.rst:114
msgid "Initializing multiple motors"
msgstr "複数のモーターの初期化"

#: ../../pupdevices/motor.rst:116
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize motors on port A and B.\n"
"track_motor = Motor(Port.A)\n"
"gripper_motor = Motor(Port.B)\n"
"\n"
"# Make both motors run at 500 degrees per second.\n"
"track_motor.run(500)\n"
"gripper_motor.run(500)\n"
"\n"
"# Wait for three seconds.\n"
"wait(3000)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A と B に繋いだ２つのモーターの初期化。\n"
"track_motor = Motor(Port.A)\n"
"gripper_motor = Motor(Port.B)\n"
"\n"
"# 両方のモーターを 500°/s 動かす。\n"
"track_motor.run(500)\n"
"gripper_motor.run(500)\n"
"\n"
"# 3秒待機。\n"
"wait(3000)\n"

#: ../../pupdevices/motor.rst:120
msgid "Setting the positive direction as counterclockwise"
msgstr "正方向を反時計回りに設定"

#: ../../pupdevices/motor.rst:122
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port, Direction\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A with the positive direction as "
"counterclockwise.\n"
"example_motor = Motor(Port.A, Direction.COUNTERCLOCKWISE)\n"
"\n"
"# When we choose a positive speed value, the motor now goes "
"counterclockwise.\n"
"example_motor.run(500)\n"
"\n"
"# This is useful when your motor is mounted in reverse or upside down.\n"
"# By changing the positive direction, your script will be easier to read,"
"\n"
"# because a positive value now makes your robot/mechanism go forward.\n"
"\n"
"# Wait for three seconds.\n"
"wait(3000)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port, Direction\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターについて、反時計回りを正方向を\n"
"# とするように初期化。\n"
"example_motor = Motor(Port.A, Direction.COUNTERCLOCKWISE)\n"
"\n"
"# 正の速度値を指定すると、モータは今度は反時計回りに回転。\n"
"example_motor.run(500)\n"
"\n"
"# これは、モーターが逆向きに取り付けられている場合や、逆さまに取り付けられている\n"
"# 場合に有効です。正方向を変更することで、正の速度値でロボットやメカが前進する\n"
"# ようになり、スクリプトが読みやすくなります。\n"
"\n"
"# 3秒待機。\n"
"wait(3000)\n"

#: ../../pupdevices/motor.rst:126
msgid "Using gears"
msgstr "ギアの利用"

#: ../../pupdevices/motor.rst:128
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port, Direction\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A with the positive direction as "
"counterclockwise.\n"
"# Also specify one gear train with a 12-tooth and a 36-tooth gear. The "
"12-tooth\n"
"# gear is attached to the motor axle. The 36-tooth gear is at the output "
"axle.\n"
"geared_motor = Motor(Port.A, Direction.COUNTERCLOCKWISE, [12, 36])\n"
"\n"
"# Make the output axle run at 100 degrees per second. The motor speed\n"
"# is automatically increased to compensate for the gears.\n"
"geared_motor.run(100)\n"
"\n"
"# Wait for three seconds.\n"
"wait(3000)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port, Direction\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターについて、反時計回りを正方向とするように初期化。\n"
"# また、12歯と36歯のギアを持つギア列を1つ指定。12歯のギアはモータ軸に取り付け、\n"
"# 36歯のギアは出力軸に取り付けている。"
"geared_motor = Motor(Port.A, Direction.COUNTERCLOCKWISE, [12, 36])\n"
"\n"
"# 出力軸は1秒間に100度回転するようにする。モータの回転数は、ギアを補正するために\n"
"# 自動的に増加する。\n"
"geared_motor.run(100)\n"
"\n"
"# 3秒待機。\n"
"wait(3000)\n"

#: ../../pupdevices/motor.rst:132
msgid "Measurement examples"
msgstr "計測の例"

#: ../../pupdevices/motor.rst:135
msgid "Measuring the angle and speed"
msgstr "角度と速度の計測"

#: ../../pupdevices/motor.rst:137
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# Start moving at 300 degrees per second.\n"
"example_motor.run(300)\n"
"\n"
"# Display the angle and speed 50 times.\n"
"for i in range(100):\n"
"\n"
"    # Read the angle (degrees) and speed (degrees per second).\n"
"    angle = example_motor.angle()\n"
"    speed = example_motor.speed()\n"
"\n"
"    # Print the values.\n"
"    print(angle, speed)\n"
"\n"
"    # Wait some time so we can read what is displayed.\n"
"    wait(200)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターを初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# 300°/s で動作を開始。\n"
"example_motor.run(300)\n"
"\n"
"# 角度と速度を100回表示。\n"
"for i in range(100):\n"
"\n"
"    # 角度(度)と速度(度/s)を取得。\n"
"    angle = example_motor.angle()\n"
"    speed = example_motor.speed()\n"
"\n"
"    # 取得した値を表示。\n"
"    print(angle, speed)\n"
"\n"
"    # 何が表示されているかが分かるよう、少し待機。\n"
"    wait(200)\n"

#: ../../pupdevices/motor.rst:141
msgid "Resetting the measured angle"
msgstr "計測角度のリセット"

#: ../../pupdevices/motor.rst:143
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# Reset the angle to 0.\n"
"example_motor.reset_angle(0)\n"
"\n"
"# Reset the angle to 1234.\n"
"example_motor.reset_angle(1234)\n"
"\n"
"# Reset the angle to the absolute angle.\n"
"# This is only supported on motors that have\n"
"# an absolute encoder. For other motors, this\n"
"# will raise an error.\n"
"example_motor.reset_angle()\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"\n"
"# ポート A に繋いだモーターを初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# 角度を 0 にリセット。\n"
"example_motor.reset_angle(0)\n"
"\n"
"# 角度を 1234 にリセット。\n"
"example_motor.reset_angle(1234)\n"
"\n"
"# 角度を絶対角度にリセットします。\n"
"# 絶対エンコーダーを搭載しているモーターにのみ対応しています。\n"
"# その他のモーターでは、エラーが発生します。\n"
"example_motor.reset_angle()\n"

#: ../../pupdevices/motor.rst:147
msgid "Getting the absolute angle"
msgstr "絶対角度の取得"

#: ../../pupdevices/motor.rst:149
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"while True:\n"
"\n"
"    # Get the default angle value.\n"
"    angle = example_motor.angle()\n"
"\n"
"    # Get the angle between 0 and 360.\n"
"    absolute_angle = example_motor.angle() % 360\n"
"\n"
"    # Get the angle between -180 and 179.\n"
"    wrapped_angle = (example_motor.angle() + 180) % 360 - 180\n"
"\n"
"    # Print the results.\n"
"    print(angle, absolute_angle, wrapped_angle)\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターを初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"while True:\n"
"\n"
"    # デフォルトの角度を取得。\n"
"    angle = example_motor.angle()\n"
"\n"
"    # 0 から 360 度の間で角度を取得。\n"
"    absolute_angle = example_motor.angle() % 360\n"
"\n"
"    # -180 から 179 度の間で角度を取得。\n"
"    wrapped_angle = (example_motor.angle() + 180) % 360 - 180\n"
"\n"
"    # 結果を表示。\n"
"    print(angle, absolute_angle, wrapped_angle)\n"
"    wait(100)\n"

#: ../../pupdevices/motor.rst:154
msgid "Movement examples"
msgstr "動作の例"

#: ../../pupdevices/motor.rst:157
msgid "Basic usage of all run methods"
msgstr "すべての run メソッドの基本的な使い方"

#: ../../pupdevices/motor.rst:159
#, python-format
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# Run at 500 deg/s and then stop by coasting.\n"
"print(\"Demo of run\")\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.stop()\n"
"wait(1500)\n"
"\n"
"# Run at 70% duty cycle (\"power\") and then stop by coasting.\n"
"print(\"Demo of dc\")\n"
"example_motor.dc(50)\n"
"wait(1500)\n"
"example_motor.stop()\n"
"wait(1500)\n"
"\n"
"# Run at 500 deg/s for two seconds.\n"
"print(\"Demo of run_time\")\n"
"example_motor.run_time(500, 2000)\n"
"wait(1500)\n"
"\n"
"# Run at 500 deg/s for 90 degrees.\n"
"print(\"Demo of run_angle\")\n"
"example_motor.run_angle(500, 90)\n"
"wait(1500)\n"
"\n"
"# Run at 500 deg/s back to the 0 angle\n"
"print(\"Demo of run_target to 0\")\n"
"example_motor.run_target(500, 0)\n"
"wait(1500)\n"
"\n"
"# Run at 500 deg/s back to the -90 angle\n"
"print(\"Demo of run_target to -90\")\n"
"example_motor.run_target(500, -90)\n"
"wait(1500)\n"
"\n"
"# Run at 500 deg/s until the motor stalls\n"
"print(\"Demo of run_until_stalled\")\n"
"example_motor.run_until_stalled(500)\n"
"print(\"Done\")\n"
"wait(1500)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターを初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# 500°/s で動作後、惰性で停止。\n"
"print(\"Demo of run\")\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.stop()\n"
"wait(1500)\n"
"\n"
"# Run at 70% のデューティ比(\"パワー\")で動作後、惰性で停止。\n"
"print(\"Demo of dc\")\n"
"example_motor.dc(50)\n"
"wait(1500)\n"
"example_motor.stop()\n"
"wait(1500)\n"
"\n"
"# 500°/s で2秒間動作。\n"
"print(\"Demo of run_time\")\n"
"example_motor.run_time(500, 2000)\n"
"wait(1500)\n"
"\n"
"# 500°/s で 90° になるまで動作。\n"
"print(\"Demo of run_angle\")\n"
"example_motor.run_angle(500, 90)\n"
"wait(1500)\n"
"\n"
"# 500°/s で 0° に戻るまで動作。\n"
"print(\"Demo of run_target to 0\")\n"
"example_motor.run_target(500, 0)\n"
"wait(1500)\n"
"\n"
"# 500°/s で -90° に戻るまで動作。\n"
"print(\"Demo of run_target to -90\")\n"
"example_motor.run_target(500, -90)\n"
"wait(1500)\n"
"\n"
"# 500°/s でモーターが失速するまで動作。\n"
"print(\"Demo of run_until_stalled\")\n"
"example_motor.run_until_stalled(500)\n"
"print(\"Done\")\n"
"wait(1500)\n"

#: ../../pupdevices/motor.rst:163
msgid "Stopping ongoing movements in different ways"
msgstr "動作を停止させるさまざまな方法"

#: ../../pupdevices/motor.rst:165
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# Run at 500 deg/s and then stop by coasting.\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.stop()\n"
"wait(1500)\n"
"\n"
"# Run at 500 deg/s and then stop by braking.\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.brake()\n"
"wait(1500)\n"
"\n"
"# Run at 500 deg/s and then stop by holding.\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.hold()\n"
"wait(1500)\n"
"\n"
"# Run at 500 deg/s and then stop by running at 0 speed.\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.run(0)\n"
"wait(1500)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターを初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# 500°/s で動作後、惰性で停止。\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.stop()\n"
"wait(1500)\n"
"\n"
"# 500°/s で動作後、ブレーキで停止。\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.brake()\n"
"wait(1500)\n"
"\n"
"# 500°/s で動作後、現状角度維持で停止。\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.hold()\n"
"wait(1500)\n"
"\n"
"# 500°/s で動作後、速度を 0 にすることで停止。\n"
"# Run at 500 deg/s and then stop by running at 0 speed.\n"
"example_motor.run(500)\n"
"wait(1500)\n"
"example_motor.run(0)\n"
"wait(1500)\n"

#: ../../pupdevices/motor.rst:169
msgid "Using the ``then`` argument to change how a run command stops"
msgstr "動作コマンドの停止方法に ``then`` 引数を使う方法"

#: ../../pupdevices/motor.rst:171
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port, Stop\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# By default, the motor holds the position. It keeps\n"
"# correcting the angle if you move it.\n"
"example_motor.run_angle(500, 360)\n"
"wait(1000)\n"
"\n"
"# This does exactly the same as above.\n"
"example_motor.run_angle(500, 360, then=Stop.HOLD)\n"
"wait(1000)\n"
"\n"
"# You can also brake. This applies some resistance\n"
"# but the motor does not move back if you move it.\n"
"example_motor.run_angle(500, 360, then=Stop.BRAKE)\n"
"wait(1000)\n"
"\n"
"# This makes the motor coast freely after it stops.\n"
"example_motor.run_angle(500, 360, then=Stop.COAST)\n"
"wait(1000)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port, Stop\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターを初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# デフォルトで、モーターは角度を維持する。\n"
"# つまり、角度を補正し続ける。\n"
"example_motor.run_angle(500, 360)\n"
"wait(1000)\n"
"\n"
"# これは上のものと全く同じ。\n"
"example_motor.run_angle(500, 360, then=Stop.HOLD)\n"
"wait(1000)\n"
"\n"
"# ブレーキをかけることもできる。これは多少の抵抗を加えるが、\n"
"# 動いてしまった分を元に戻しません。\n"
"example_motor.run_angle(500, 360, then=Stop.BRAKE)\n"
"wait(1000)\n"
"\n"
"# この指定で、モーターは停止後に自由に惰性で動く。\n"
"example_motor.run_angle(500, 360, then=Stop.COAST)\n"
"wait(1000)\n"

#: ../../pupdevices/motor.rst:175
msgid "Stall examples"
msgstr "失速に関する例"

#: ../../pupdevices/motor.rst:178
msgid "Running a motor until a mechanical endpoint"
msgstr "機構的な終点までモータを回転させる"

#: ../../pupdevices/motor.rst:180
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# We'll use a speed of 200 deg/s in all our commands.\n"
"speed = 200\n"
"\n"
"# Run the motor in reverse until it hits a mechanical stop.\n"
"# The duty_limit=30 setting means that it will apply only 30%\n"
"# of the maximum torque against the mechanical stop. This way,\n"
"# you don't push against it with too much force.\n"
"example_motor.run_until_stalled(-speed, duty_limit=30)\n"
"\n"
"# Reset the angle to 0. Now whenever the angle is 0, you know\n"
"# that it has reached the mechanical endpoint.\n"
"example_motor.reset_angle(0)\n"
"\n"
"# Now make the motor go back and forth in a loop.\n"
"# This will now work the same regardless of the\n"
"# initial motor angle, because we always start\n"
"# from the mechanical endpoint.\n"
"for count in range(10):\n"
"    example_motor.run_target(speed, 180)\n"
"    example_motor.run_target(speed, 90)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"\n"
"# ポート A に繋いだモーターを初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# すべてのコマンドで200°/sの速度を使うことにする。\n"
"speed = 200\n"
"\n"
"# 機械的な停止までモーターを逆回転させる。\n"
"# duty_limit=30 の設定は、機械的な停止に対して最大トルクの30%\n"
"# しかかけないことを意味する。このようにすることで、あまり強い力をかけ\n"
"# すぎないようにできる。\n"
"example_motor.run_until_stalled(-speed, duty_limit=30)\n"
"\n"
"# これにより角度が0になるたびに、機械的な停止になったことが分かる。\n"
"example_motor.reset_angle(0)\n"
"\n"
"# 今度は、モーターをループで前後進させる。\n"
"# 常に機械的な終点からスタートするので、\n"
"# モータの初期角度に関係なく同じように動作する。\n"
"for count in range(10):\n"
"    example_motor.run_target(speed, 180)\n"
"    example_motor.run_target(speed, 90)\n"

#: ../../pupdevices/motor.rst:184
msgid "Centering a steering mechanism"
msgstr "ステアリング機構のセンタリング"

#: ../../pupdevices/motor.rst:186
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize a motor on port A.\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# Please have a look at the previous example first. This example\n"
"# finds two endspoints and then makes the middle the zero point.\n"
"\n"
"# The run_until_stalled gives us the angle at which it stalled.\n"
"# We want to know this value for both endpoints.\n"
"left_end = example_motor.run_until_stalled(-200, duty_limit=30)\n"
"right_end = example_motor.run_until_stalled(200, duty_limit=30)\n"
"\n"
"# We have just moved to the rightmost endstop. So, we can reset\n"
"# this angle to be half the distance between the two endpoints.\n"
"# That way, the middle corresponds to 0 degrees.\n"
"example_motor.reset_angle((right_end - left_end) / 2)\n"
"\n"
"# From now on we can simply run towards zero to reach the middle.\n"
"example_motor.run_target(200, 0)\n"
"\n"
"wait(1000)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A に繋いだモーターを初期化。\n"
"example_motor = Motor(Port.A)\n"
"\n"
"# まず、前の例を参照。この例では2つの端点を求め、真ん中をゼロ点としている。\n"
"\n"
"# run_until_stalled で失速した角度を出している。\n"
"# これで、知りたい両端点での角度が得られる。\n"
"left_end = example_motor.run_until_stalled(-200, duty_limit=30)\n"
"right_end = example_motor.run_until_stalled(200, duty_limit=30)\n"
"\n"
"# 一番右の端点に移動している。そこで、この角度をリセットして、2つの\n"
"# 端点間の距離の半分にすればいい。\n"
"# そうすると、真ん中が0度に対応する。\n"
"example_motor.reset_angle((right_end - left_end) / 2)\n"
"\n"
"# こうすれば、ゼロに向かって動かすだけで真ん中に到することができる。\n"
"example_motor.run_target(200, 0)\n"
"\n"
"wait(1000)\n"

#: ../../pupdevices/motor.rst:191
msgid "Parallel movement examples"
msgstr "並列動作の例"

#: ../../pupdevices/motor.rst:194
msgid "Using the ``wait`` argument to run motors in parallel"
msgstr "並列動作させるのに ``wait`` 引数を使う例"

#: ../../pupdevices/motor.rst:196
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"\n"
"# Initialize motors on port A and B.\n"
"track_motor = Motor(Port.A)\n"
"gripper_motor = Motor(Port.B)\n"
"\n"
"# Make the track motor start moving,\n"
"# but don't wait for it to finish.\n"
"track_motor.run_angle(500, 360, wait=False)\n"
"\n"
"# Now make the gripper motor rotate. This\n"
"# means they move at the same time.\n"
"gripper_motor.run_angle(200, 720)\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"\n"
"# ポート A と B に繋いだ２つのモーターの初期化。\n"
"track_motor = Motor(Port.A)\n"
"gripper_motor = Motor(Port.B)\n"
"\n"
"# 走行用モーターの動作を開始するが、\n"
"# 動作の終了は待たない。\n"
"track_motor.run_angle(500, 360, wait=False)\n"
"\n"
"# ここで、旋回用モーターを回転させる。\n"
"# つまり、走行用と同時に動くことになる。\n"
"gripper_motor.run_angle(200, 720)\n"

#: ../../pupdevices/motor.rst:200
msgid "Waiting for two parallel actions to complete"
msgstr "2つの並列動作の完了待機"

#: ../../pupdevices/motor.rst:202
msgid ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize motors on port A and B.\n"
"track_motor = Motor(Port.A)\n"
"gripper_motor = Motor(Port.B)\n"
"\n"
"# Make both motors perform an action with wait=False\n"
"track_motor.run_angle(500, 360, wait=False)\n"
"gripper_motor.run_angle(200, 720, wait=False)\n"
"\n"
"# While one or both of the motors are not done yet,\n"
"# do something else. In this example, just wait.\n"
"while not track_motor.done() or not gripper_motor.done():\n"
"    wait(10)\n"
"\n"
"print(\"Both motors are done!\")\n"
msgstr ""
"from pybricks.pupdevices import Motor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# ポート A と B に繋いだ２つのモーターの初期化。\n"
"track_motor = Motor(Port.A)\n"
"gripper_motor = Motor(Port.B)\n"
"\n"
"# 両方のモーターを wait=False で動作をさせる。\n"
"track_motor.run_angle(500, 360, wait=False)\n"
"gripper_motor.run_angle(200, 720, wait=False)\n"
"\n"
"# 片方または両方のモーターがまだ終わらない間に 他のことをする。\n"
"# この例では、ただ待つだけ。\n"
"while not track_motor.done() or not gripper_motor.done():\n"
"    wait(10)\n"
"\n"
"print(\"Both motors are done!\")\n"

#: ../../pupdevices/pfmotor.rst:4
msgid "Power Functions"
msgstr "パワーファンクション"

#: ../../pupdevices/pfmotor.rst:6
msgid ""
"The :class:`ColorDistanceSensor "
"<pybricks.pupdevices.ColorDistanceSensor>` can send infrared signals to "
"control Power Functions infrared receivers. You can use this technique to"
" control medium, large, extra large, and train motors. The infrared range"
" is limited to about 30 cm, depending on the angle and ambient "
"conditions."
msgstr ""
":class:`ColorDistanceSensor <pybricks.pupdevices.ColorDistanceSensor>` "
"は、赤外線信号を送信してパワーファンクションの赤外線レシーバーを制御できます。"
"この技術を使って、中型、大型、特大、列車用モーターを制御できます。"
"赤外線の到達距離は、角度や周囲の状況にもよりますが、約 30 cm が限界です。"

#: ../../pupdevices/pfmotor.rst:15
msgid ""
"Powered Up :class:`ColorDistanceSensor "
"<pybricks.pupdevices.ColorDistanceSensor>` (left), Power Functions "
"infrared receiver (middle), and a Power Functions motor (right). Here, "
"the receiver uses channel 1 with a motor on the red port."
msgstr ""
"Power Up :class:`ColorDistanceSensor "
"<pybricks.pupdevices.ColorDistanceSensor>` (左)、"
"パワーファンクションの赤外線レシーバー(中央)、パワーファンクションのモーター(右)。"
"ここでは、レシーバーはチャンネル1を使用し、赤のポートにモーターを繋いでいます。"

#: of pybricks.pupdevices.PFMotor:1
msgid ""
"Control Power Functions motors with the infrared functionality of the "
":class:`ColorDistanceSensor <pybricks.pupdevices.ColorDistanceSensor>`."
msgstr ""
":class:`ColorDistanceSensor <pybricks.pupdevices.ColorDistanceSensor>` "
"の赤外線機能でパワーファンクションのモーターを制御します。"

#: of pybricks.pupdevices.PFMotor:4
msgid "Sensor object."
msgstr "Sensor オブジェクト。"

#: of pybricks.pupdevices.PFMotor:6
msgid "Channel number of the receiver: ``1``, ``2``, ``3``, or ``4``."
msgstr "受信機のチャンネル番号: ``1``, ``2``, ``3``, ``4`` のいずれか。"

#: of pybricks.pupdevices.PFMotor:8
msgid ""
"Color marker on the receiver: :class:`Color.BLUE <.parameters.Color>` or "
":class:`Color.RED <.parameters.Color>`"
msgstr ""
"受信機のカラーマーカー: "
":class:`Color.BLUE <.parameters.Color>` または "
":class:`Color.RED <.parameters.Color>`"

#: ../../pupdevices/pfmotor.rst:38
msgid "Control a Power Functions motor"
msgstr "パワーファンクションのモーターの制御"

#: ../../pupdevices/pfmotor.rst:40
msgid ""
"from pybricks.pupdevices import ColorDistanceSensor, PFMotor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorDistanceSensor(Port.B)\n"
"\n"
"# Initialize a motor on channel 1, on the red output.\n"
"motor = PFMotor(sensor, 1, Color.RED)\n"
"\n"
"# Rotate and then stop.\n"
"motor.dc(100)\n"
"wait(1000)\n"
"motor.stop()\n"
"wait(1000)\n"
"\n"
"# Rotate the other way at half speed, and then stop.\n"
"motor.dc(-50)\n"
"wait(1000)\n"
"motor.stop()\n"
msgstr ""
"from pybricks.pupdevices import ColorDistanceSensor, PFMotor\n"
"from pybricks.parameters import Port, Color\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorDistanceSensor(Port.B)\n"
"\n"
"# チャンネル１、赤のポートに繋いだモーターを初期化。\n"
"motor = PFMotor(sensor, 1, Color.RED)\n"
"\n"
"# 回転と停止。\n"
"motor.dc(100)\n"
"wait(1000)\n"
"motor.stop()\n"
"wait(1000)\n"
"\n"
"# 逆向き、半分のスピードで回転して停止。\n"
"motor.dc(-50)\n"
"wait(1000)\n"
"motor.stop()\n"

#: ../../pupdevices/pfmotor.rst:44
msgid "Controlling multiple Power Functions motors"
msgstr "複数のパワーファンクションのモーターの制御"

#: ../../pupdevices/pfmotor.rst:46
msgid ""
"from pybricks.pupdevices import ColorDistanceSensor, PFMotor\n"
"from pybricks.parameters import Port, Color, Direction\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"sensor = ColorDistanceSensor(Port.B)\n"
"\n"
"# You can use multiple motors on different channels.\n"
"arm = PFMotor(sensor, 1, Color.BLUE)\n"
"wheel = PFMotor(sensor, 4, Color.RED, Direction.COUNTERCLOCKWISE)\n"
"\n"
"# Accelerate both motors. Only these values are available.\n"
"# Other values will be rounded down to the nearest match.\n"
"for duty in [15, 30, 45, 60, 75, 90, 100]:\n"
"    arm.dc(duty)\n"
"    wheel.dc(duty)\n"
"    wait(1000)\n"
"\n"
"# To make the signal more reliable, there is a short\n"
"# pause between commands. So, they change speed and\n"
"# stop at a slightly different time.\n"
"\n"
"# Brake both motors.\n"
"arm.brake()\n"
"wheel.brake()\n"
msgstr ""
"from pybricks.pupdevices import ColorDistanceSensor, PFMotor\n"
"from pybricks.parameters import Port, Color, Direction\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"sensor = ColorDistanceSensor(Port.B)\n"
"\n"
"# 複数のモーターを別々のチャンネルに繋いで利用できる。\n"
"arm = PFMotor(sensor, 1, Color.BLUE)\n"
"wheel = PFMotor(sensor, 4, Color.RED, Direction.COUNTERCLOCKWISE)\n"
"\n"
"# 両モーターを加速する。これらの値のみ利用可能。\n"
"# 他の値は切り捨てて、最も近い値になる。\n"
"for duty in [15, 30, 45, 60, 75, 90, 100]:\n"
"    arm.dc(duty)\n"
"    wheel.dc(duty)\n"
"    wait(1000)\n"
"\n"
"# 信号をより確実にするために、コマンドとコマンドの間に\n"
"# 短い間がある。そのため、速度を変えたり、少しずらした\n"
"# タイミングで止まったりする。\n"
"\n"
"# 両モーターにブレーキをかける。\n"
"arm.brake()\n"
"wheel.brake()\n"

#: ../../pupdevices/remote.rst:4
msgid "Remote Control"
msgstr "リモコン"

#: of pybricks.pupdevices.Remote:1
msgid "LEGO® Powered Up Bluetooth Remote Control."
msgstr "LEGO® Powered Up Bluetooth リモコン。"

#: of pybricks.pupdevices.Remote:3
msgid ""
"When you instantiate this class, the hub will search for a remote and "
"connect automatically."
msgstr ""
"このクラスをインスタンス化すると、ハブはリモコンを検索し、"
"自動的に接続します。"

#: of pybricks.pupdevices.Remote:6
msgid ""
"The remote must be on and ready for a connection, as indicated by a white"
" blinking light."
msgstr ""
"リモコンは、白色の点滅で示されるように、電源が入っており、"
"接続可能な状態である必要があります。"

#: of pybricks.pupdevices.Remote:9
msgid ""
"Bluetooth name of the remote. If no name is given, the hub connects to "
"the first remote that it finds."
msgstr ""
"リモコンの Bluetooth 名を指定します。名前を指定しない場合、"
"ハブは最初に見つけたリモコンに接続します。"

#: of pybricks.pupdevices.Remote:12
msgid "How long to search for the remote."
msgstr "リモコンを検索する時間。"

#: of pybricks.pupdevices.Remote.name:1
msgid "Sets or gets the Bluetooth name of the remote."
msgstr "リモコンの Bluetooth 名を設定または取得します。"

#: of pybricks.pupdevices.Remote.name:3
msgid ""
"New Bluetooth name of the remote. If no name is given, this method "
"returns the current name."
msgstr ""
"リモートの新しい Bluetooth名。"
"name を指定しない場合、このメソッドは現在の名前を返します。"

#: of pybricks._common.Keypad.pressed:1
msgid "Checks which buttons are currently pressed."
msgstr "どのボタンが押されているかをチェックします。"

#: of pybricks._common.Keypad.pressed:3
msgid "Set of pressed buttons."
msgstr "押されているボタンの集合。"

#: ../../pupdevices/remote.rst:24
msgid "Checking which buttons are pressed"
msgstr "どのボタンが押されているかのチェック"

#: ../../pupdevices/remote.rst:26
msgid ""
"from pybricks.pupdevices import Remote\n"
"from pybricks.parameters import Button\n"
"from pybricks.tools import wait\n"
"\n"
"# Connect to the remote.\n"
"my_remote = Remote()\n"
"\n"
"while True:\n"
"    # Check which buttons are pressed.\n"
"    pressed = my_remote.buttons.pressed()\n"
"\n"
"    # Show the result.\n"
"    print(\"pressed:\", pressed)\n"
"\n"
"    # Check a specific button.\n"
"    if Button.CENTER in pressed:\n"
"        print(\"You pressed the center button!\")\n"
"\n"
"    # Wait so we can see the result.\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import Remote\n"
"from pybricks.parameters import Button\n"
"from pybricks.tools import wait\n"
"\n"
"# リモコンに接続。\n"
"my_remote = Remote()\n"
"\n"
"while True:\n"
"    # どのボタンが押されているかのチェック。\n"
"    pressed = my_remote.buttons.pressed()\n"
"\n"
"    # 結果を表示。\n"
"    print(\"pressed:\", pressed)\n"
"\n"
"    # 特定のボタンをチェック。\n"
"    if Button.CENTER in pressed:\n"
"        print(\"You pressed the center button!\")\n"
"\n"
"    # 結果を確認できるよう、少し待機。\n"
"    wait(100)\n"

#: ../../pupdevices/remote.rst:30
msgid "Changing the remote light color"
msgstr "リモコンのライト色の変更"

#: ../../pupdevices/remote.rst:32
msgid ""
"from pybricks.pupdevices import Remote\n"
"from pybricks.parameters import Color\n"
"from pybricks.tools import wait\n"
"\n"
"# Connect to the remote.\n"
"remote = Remote()\n"
"\n"
"while True:\n"
"    # Set the color to red.\n"
"    remote.light.on(Color.RED)\n"
"    wait(1000)\n"
"\n"
"    # Set the color to blue.\n"
"    remote.light.on(Color.BLUE)\n"
"    wait(1000)\n"
msgstr ""
"from pybricks.pupdevices import Remote\n"
"from pybricks.parameters import Color\n"
"from pybricks.tools import wait\n"
"\n"
"# リモコンに接続。\n"
"remote = Remote()\n"
"\n"
"while True:\n"
"    # 色を赤に設定。\n"
"    remote.light.on(Color.RED)\n"
"    wait(1000)\n"
"\n"
"    # 色を青に設定。\n"
"    remote.light.on(Color.BLUE)\n"
"    wait(1000)\n"

#: ../../pupdevices/remote.rst:36
msgid "Changing the light color using the buttons"
msgstr "ボタンを使ったライト色の変更"

#: ../../pupdevices/remote.rst:38
msgid ""
"from pybricks.pupdevices import Remote\n"
"from pybricks.parameters import Button, Color\n"
"\n"
"\n"
"def button_to_color(buttons):\n"
"\n"
"    # Return a color depending on the button.\n"
"    if Button.LEFT_PLUS in buttons:\n"
"        return Color.RED\n"
"    if Button.LEFT_MINUS in buttons:\n"
"        return Color.GREEN\n"
"    if Button.LEFT in buttons:\n"
"        return Color.ORANGE\n"
"    if Button.RIGHT_PLUS in buttons:\n"
"        return Color.BLUE\n"
"    if Button.RIGHT_MINUS in buttons:\n"
"        return Color.YELLOW\n"
"    if Button.RIGHT in buttons:\n"
"        return Color.CYAN\n"
"    if Button.CENTER in buttons:\n"
"        return Color.VIOLET\n"
"\n"
"    # Return no color by default.\n"
"    return Color.NONE\n"
"\n"
"\n"
"# Connect to the remote.\n"
"remote = Remote()\n"
"\n"
"while True:\n"
"    # Wait until a button is pressed.\n"
"    pressed = ()\n"
"    while not pressed:\n"
"        pressed = remote.buttons.pressed()\n"
"\n"
"    # Convert button code to color.\n"
"    color = button_to_color(pressed)\n"
"\n"
"    # Set the remote light color.\n"
"    remote.light.on(color)\n"
"\n"
"    # Wait until all buttons are released.\n"
"    while pressed:\n"
"        pressed = remote.buttons.pressed()\n"
msgstr ""
"from pybricks.pupdevices import Remote\n"
"from pybricks.parameters import Button, Color\n"
"\n"
"\n"
"def button_to_color(buttons):\n"
"\n"
"    # ボタンごとの色を返す。\n"
"    if Button.LEFT_PLUS in buttons:\n"
"        return Color.RED\n"
"    if Button.LEFT_MINUS in buttons:\n"
"        return Color.GREEN\n"
"    if Button.LEFT in buttons:\n"
"        return Color.ORANGE\n"
"    if Button.RIGHT_PLUS in buttons:\n"
"        return Color.BLUE\n"
"    if Button.RIGHT_MINUS in buttons:\n"
"        return Color.YELLOW\n"
"    if Button.RIGHT in buttons:\n"
"        return Color.CYAN\n"
"    if Button.CENTER in buttons:\n"
"        return Color.VIOLET\n"
"\n"
"    # デフォルトの色を返す。\n"
"    return Color.NONE\n"
"\n"
"\n"
"# リモコンに接続。\n"
"remote = Remote()\n"
"\n"
"while True:\n"
"    # ボタンが押されるのを待つ。\n"
"    pressed = ()\n"
"    while not pressed:\n"
"        pressed = remote.buttons.pressed()\n"
"\n"
"    # ボタンのコードを色に変換。\n"
"    color = button_to_color(pressed)\n"
"\n"
"    # リモコンのライト色を設定。\n"
"    remote.light.on(color)\n"
"\n"
"    # すべてのボタンを放すまで待機。\n"
"    while pressed:\n"
"        pressed = remote.buttons.pressed()\n"

#: ../../pupdevices/remote.rst:43
msgid "Using the timeout setting"
msgstr "タイムアウト設定の利用"

#: ../../pupdevices/remote.rst:45
msgid ""
"You can use the ``timeout`` argument to change for how long the hub "
"searches for the remote. If you choose ``None``, it will search forever."
msgstr ""
"``timeout`` 引数を使うと、ハブがリモコンを検索する時間を変更できます。 "
"``None`` を選択すると、永遠に検索し続けます。"

#: ../../pupdevices/remote.rst:48
msgid ""
"from pybricks.pupdevices import Remote\n"
"\n"
"# Connect to any remote. Search forever until we find one.\n"
"my_remote = Remote(timeout=None)\n"
"\n"
"print(\"Connected!\")\n"
msgstr ""
"from pybricks.pupdevices import Remote\n"
"\n"
"# あらゆるリモコンに接続する。見つけるまで永遠に探し続ける。\n"
"my_remote = Remote(timeout=None)\n"
"\n"
"print(\"Connected!\")\n"

#: ../../pupdevices/remote.rst:52
msgid ""
"If the remote was not found within the specified ``timeout``, an "
":ref:`OSError <OSError>` is raised. You can catch this exception to run "
"other code if the remote is not available."
msgstr ""
"指定したタイムアウト時間内にリモコンが見つからなかった場合、 "
":ref:`OSError <OSError>` が発生します。この例外をキャッチして、"
"リモコンが利用できない場合に他のコードを実行するようにできます。"

#: ../../pupdevices/remote.rst:57
msgid ""
"from pybricks.pupdevices import Remote\n"
"\n"
"try:\n"
"    # Search for a remote for 5 seconds.\n"
"    my_remote = Remote(timeout=5000)\n"
"\n"
"    print(\"Connected!\")\n"
"\n"
"    # Here you can write code that uses the remote.\n"
"\n"
"except OSError:\n"
"\n"
"    print(\"Could not find the remote.\")\n"
"\n"
"    # Here you can make your robot do something\n"
"    # without the remote.\n"
msgstr ""
"from pybricks.pupdevices import Remote\n"
"\n"
"try:\n"
"    # リモコンを５秒間検索。\n"
"    my_remote = Remote(timeout=5000)\n"
"\n"
"    print(\"Connected!\")\n"
"\n"
"    # ここに、リモコンを使うコードを記述できる。\n"
"\n"
"except OSError:\n"
"\n"
"    print(\"Could not find the remote.\")\n"
"\n"
"    # ここに、リモコンを使わずにロボットに\n"
"    # 何かをさせることができる。\n"

#: ../../pupdevices/remote.rst:61
msgid "Changing the name of the remote"
msgstr "リモコンの名前を変更#

#: ../../pupdevices/remote.rst:63
msgid ""
"You can change the Bluetooth name of the remote. The factory default name"
" is ``Handset``."
msgstr ""
"リモコンの Bluetooth 名を変更できます。工場出荷時の名前は ``Handset`` です。"

#: ../../pupdevices/remote.rst:66
msgid ""
"from pybricks.pupdevices import Remote\n"
"\n"
"# Connect to any remote.\n"
"my_remote = Remote()\n"
"\n"
"# Print the current name of the remote.\n"
"print(my_remote.name())\n"
"\n"
"# Choose a new name.\n"
"my_remote.name(\"truck2\")\n"
"\n"
"print(\"Done!\")\n"
msgstr ""
"from pybricks.pupdevices import Remote\n"
"\n"
"# リモコンに接続。\n"
"my_remote = Remote()\n"
"\n"
"# 現在のリモコンの名前を表示。\n"
"print(my_remote.name())\n"
"\n"
"# 新しい名前を設定。\n"
"my_remote.name(\"truck2\")\n"
"\n"
"print(\"Done!\")\n"

#: ../../pupdevices/remote.rst:69
msgid ""
"You can specify this name when connecting to the remote. This lets you "
"pick the right one if multiple remotes are nearby."
msgstr ""
"この名前は、リモートに接続するときに指定できます。これにより、近くに複数のリモコンが"
"ある場合に、適切なリモコンを選択できます。"

#: ../../pupdevices/remote.rst:72
msgid ""
"from pybricks.pupdevices import Remote\n"
"from pybricks.tools import wait\n"
"\n"
"# Connect to a remote called truck2.\n"
"truck_remote = Remote(\"truck2\", timeout=None)\n"
"\n"
"print(\"Connected!\")\n"
"\n"
"wait(2000)\n"
msgstr ""
"from pybricks.pupdevices import Remote\n"
"from pybricks.tools import wait\n"
"\n"
"# truck2 という名前のリモコンに接続。\n"
"truck_remote = Remote(\"truck2\", timeout=None)\n"
"\n"
"print(\"Connected!\")\n"
"\n"
"wait(2000)\n"

#: ../../pupdevices/tiltsensor.rst:4
msgid "Tilt Sensor"
msgstr "チルトセンサー"

#: of pybricks.pupdevices.TiltSensor:1
msgid "LEGO® Powered Up Tilt Sensor."
msgstr "LEGO® Powered Up チルトセンサー。"

#: of pybricks.pupdevices.TiltSensor.tilt:1
msgid "Measures the tilt relative to the horizontal plane."
msgstr "水平面に対する傾きを測定します。"

#: of pybricks.pupdevices.TiltSensor.tilt:3
msgid "Tuple of pitch and roll angles."
msgstr "ピッチ角とロール角のタプル。"

#: ../../pupdevices/tiltsensor.rst:18
msgid "Measuring pitch and roll"
msgstr "ピッチ角とロール角の計測。"

#: ../../pupdevices/tiltsensor.rst:20
msgid ""
"from pybricks.pupdevices import TiltSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"accel = TiltSensor(Port.A)\n"
"\n"
"while True:\n"
"    # Read the tilt angles relative to the horizontal plane.\n"
"    pitch, roll = accel.tilt()\n"
"\n"
"    # Print the values\n"
"    print(\"Pitch:\", pitch, \"Roll:\", roll)\n"
"\n"
"    # Wait some time so we can read what is printed.\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import TiltSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"accel = TiltSensor(Port.A)\n"
"\n"
"while True:\n"
"    # 水平面に対するチルト角度を読み取る。\n"
"    pitch, roll = accel.tilt()\n"
"\n"
"    # 値を表示\n"
"    print(\"Pitch:\", pitch, \"Roll:\", roll)\n"
"\n"
"    # 何がプリントされているかが確認できるように待機。\n"
"    wait(100)\n"

#: ../../pupdevices/ultrasonicsensor.rst:4
msgid "Ultrasonic Sensor"
msgstr "超音波センサー"

msgid ".. image:: ../main/diagrams/sensor_ultrasonic_lights.png"
msgstr ""

#: of pybricks.pupdevices.UltrasonicSensor.distance:1
msgid ""
"Measures the distance between the sensor and an object using ultrasonic "
"sound waves."
msgstr ""
"超音波を利用して、センサーと対象物との距離を計測します。"

#: of pybricks.pupdevices.UltrasonicSensor.distance:4
msgid "Measured distance. If no valid distance was measured, it returns 2000 mm."
msgstr "計測された距離。有効な距離が計測されなかった場合は 2000 mm を返します。"

#: of pybricks.pupdevices.UltrasonicSensor.presence:1
msgid ""
"Checks for the presence of other ultrasonic sensors by detecting "
"ultrasonic sounds."
msgstr ""
"超音波を検出することにより、他の超音波センサの存在をチェックします。"

#: of pybricks.pupdevices.UltrasonicSensor.presence:4
msgid "``True`` if ultrasonic sounds are detected, ``False`` if not."
msgstr "超音波が検出されれば ``True`` 、されなければ ``False`` 。"

#: ../../pupdevices/ultrasonicsensor.rst:18
msgid ""
"This sensor has 4 built-in lights. You can adjust the brightness of each "
"light."
msgstr ""
"このセンサーは4つのライトを内蔵しています。それぞれのライトの明るさを調整できます。"

#: of pybricks._common.LightArray4.on:3
msgid ""
"Use a single value to set the brightness of all lights at the same time. "
"Use a tuple of four values to set the brightness of each light "
"individually. The order of the lights is shown in the image above."
msgstr ""
"1つの値ですべてのライトの明るさを同時に設定できます。"
"4つの値からなるタプルを使用すると、各ライトの明るさを個別に設定できます。"
"ライトの順番は上の画像のとおりです。"

#: ../../pupdevices/ultrasonicsensor.rst:29
msgid "Measuring distance and switching on the lights"
msgstr "距離の計測とライトの点灯/消灯"

#: ../../pupdevices/ultrasonicsensor.rst:31
msgid ""
"from pybricks.pupdevices import UltrasonicSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# Initialize the sensor.\n"
"eyes = UltrasonicSensor(Port.A)\n"
"\n"
"while True:\n"
"    # Print the measured distance.\n"
"    print(eyes.distance())\n"
"\n"
"    # If an object is detected closer than 500mm:\n"
"    if eyes.distance() < 500:\n"
"        # Turn the lights on.\n"
"        eyes.lights.on(100)\n"
"    else:\n"
"        # Turn the lights off.\n"
"        eyes.lights.off()\n"
"\n"
"    # Wait some time so we can read what is printed.\n"
"    wait(100)\n"
msgstr ""
"from pybricks.pupdevices import UltrasonicSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait\n"
"\n"
"# センサーを初期化。\n"
"eyes = UltrasonicSensor(Port.A)\n"
"\n"
"while True:\n"
"    # 計測した距離を表示。\n"
"    print(eyes.distance())\n"
"\n"
"    # 対象物を 500mm より近くに検出された場合:\n"
"    if eyes.distance() < 500:\n"
"        # ライトを点灯。\n"
"        eyes.lights.on(100)\n"
"    else:\n"
"        # ライトを消灯。\n"
"        eyes.lights.off()\n"
"\n"
"    # 何が表示されているかが分かるよう、少し待機。\n"
"    wait(100)\n"

#: ../../pupdevices/ultrasonicsensor.rst:35
msgid "Gradually change the brightness of the lights"
msgstr "ライトの明るさを徐々に変更"

#: ../../pupdevices/ultrasonicsensor.rst:37
msgid ""
"from pybricks.pupdevices import UltrasonicSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait, StopWatch\n"
"\n"
"from umath import pi, sin\n"
"\n"
"# Initialize the sensor.\n"
"eyes = UltrasonicSensor(Port.A)\n"
"\n"
"# Initialize a timer.\n"
"watch = StopWatch()\n"
"\n"
"# We want one full light cycle to last three seconds.\n"
"PERIOD = 3000\n"
"\n"
"while True:\n"
"    # The phase is where we are in the unit circle now.\n"
"    phase = watch.time() / PERIOD * 2 * pi\n"
"\n"
"    # Each light follows a sine wave with a mean of 50, with an amplitude"
" of 50.\n"
"    # We offset this sine wave by 90 degrees for each light, so that all "
"the\n"
"    # lights do something different.\n"
"    brightness = [sin(phase + offset * pi / 2) * 50 + 50 for offset in "
"range(4)]\n"
"\n"
"    # Set the brightness values for all lights.\n"
"    eyes.lights.on(brightness)\n"
"\n"
"    # Wait some time.\n"
"    wait(50)\n"
msgstr ""
"from pybricks.pupdevices import UltrasonicSensor\n"
"from pybricks.parameters import Port\n"
"from pybricks.tools import wait, StopWatch\n"
"\n"
"from umath import pi, sin\n"
"\n"
"# センサーを初期化。\n"
"eyes = UltrasonicSensor(Port.A)\n"
"\n"
"# タイマーを初期化。\n"
"watch = StopWatch()\n"
"\n"
"# ライトの1回の全サイクルが3秒になるようする。\n"
"PERIOD = 3000\n"
"\n"
"while True:\n"
"    # phase は、現在、単位円のどこにいるかを示す。\n"
The phase is where we are in the unit circle now.\n"
"    phase = watch.time() / PERIOD * 2 * pi\n"
"\n"
"    # 各ライトは、平均値50、振幅50の正弦波にしたがう。\n"
"    # この正弦波を各ライトごとに90度ずつオフセットして、\n"
"    # すべてのライトが異なる動きをするようにした。\n"
"    brightness = [sin(phase + offset * pi / 2) * 50 + 50 for offset in "
"range(4)]\n"
"\n"
"    # すべてのライトの照度の値を設定。\n"
"    eyes.lights.on(brightness)\n"
"\n"
"    # 少し待機。\n"
"    wait(50)\n"

